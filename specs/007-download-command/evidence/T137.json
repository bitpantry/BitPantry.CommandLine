{
  "taskId": "T137",
  "testCase": "",
  "red": {
    "timestamp": "2026-01-14T15:57:02.0980858-06:00",
    "testCommand": "runTests Execute_SomeFilesFailed_DisplaysPartialSuccessWithFailureDetails",
    "exitCode": 0,
    "output": "Test passed (backfill - behavior already implemented)",
    "testFile": "BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs",
    "testMethod": "Execute_SomeFilesFailed_DisplaysPartialSuccessWithFailureDetails"
  },
  "green": {
    "timestamp": "2026-01-14T15:57:07.8773399-06:00",
    "testCommand": "runTests Execute_SomeFilesFailed_DisplaysPartialSuccessWithFailureDetails",
    "exitCode": 0,
    "output": "Passed: 1, Failed: 0"
  },
  "diff": {
    "timestamp": "2026-01-14T15:57:07.8773399-06:00",
    "files": [
      ".claude/commands/speckit.execute-batch.md",
      ".claude/commands/speckit.execute.md",
      "BitPantry.CommandLine.Remote.SignalR.Client/FileTransferService.cs",
      "BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs",
      "BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/UploadCommandTests.cs",
      "specs/007-download-command/batch-state.json",
      "specs/007-download-command/batches/batch-006.md"
    ],
    "patch": "diff --git a/.claude/commands/speckit.execute-batch.md b/.claude/commands/speckit.execute-batch.md\nindex c525730..215d38a 100644\n--- a/.claude/commands/speckit.execute-batch.md\n+++ b/.claude/commands/speckit.execute-batch.md\n@@ -75,8 +75,16 @@ Check the batch file for a \"Backfill Execution Mode\" section. If present:\n    - Γ¥î \"Code exists and uses constant X, so I'll test that X=100\" ΓÇö INVALID\n    - Γ£à \"Code uses constant X to control behavior Y, so I'll test that Y works correctly\"\n    \n+   > **≡ƒôï See `.specify/memory/invalid-test-patterns.md` for the full invalid patterns list.**\n+   \n    **Backfill tests must pass the same validity checks as REDΓåÆGREEN tests.**\n    Before recording GREEN, answer: **\"If someone broke the behavior, would this test catch it?\"**\n+   \n+   **If you find an existing pattern to copy:**\n+   - Verify the existing test itself passes the Mandatory Validation Checkpoint\n+   - If the existing test is invalid, do NOT copy it ΓÇö write a valid test instead\n+   - Report: `Pattern found in [file] ΓÇö validated as [VALID/INVALID because...]`\n+   - If INVALID, report: `ΓÜá∩╕Å EXISTING TEST INVALID: [file]:[method] ΓÇö [reason]`\n \n **ΓÜá∩╕Å CRITICAL: Backfill mode modifies ONLY the RED phase. All other steps remain MANDATORY:**\n - **Step 1b (Infrastructure Analysis) ΓÇö NEVER SKIP** ΓÇö You must still analyze test infrastructure\ndiff --git a/.claude/commands/speckit.execute.md b/.claude/commands/speckit.execute.md\nindex a99c8d0..89879e2 100644\n--- a/.claude/commands/speckit.execute.md\n+++ b/.claude/commands/speckit.execute.md\n@@ -138,6 +138,14 @@ This command executes **exactly ONE task** using strict Test-Driven Development.\n    - Reuse established test infrastructure (setup helpers, mocks, assertions)\n    - Follow naming convention: `MethodUnderTest_Scenario_ExpectedBehavior`\n \n+   ΓÜá∩╕Å **Existing tests are NOT pre-validated.** Tests in the codebase may themselves be invalid. When following an existing pattern, you MUST still apply the Mandatory Validation Checkpoint (see `.specify/memory/invalid-test-patterns.md`). \"It's already in the codebase\" is not evidence of correctness.\n+   \n+   **If you find a pattern to copy:**\n+   - Verify the existing test itself passes the Mandatory Validation Checkpoint\n+   - If the existing test is invalid, do NOT copy it ΓÇö write a valid test instead\n+   - Report: `Pattern found in [file] ΓÇö validated as [VALID/INVALID because...]`\n+   - If INVALID, report: `ΓÜá∩╕Å EXISTING TEST INVALID: [file]:[method] ΓÇö [reason]`\n+\n 3. **Write the test**:\n    - Use the testing framework from constitution (MSTest + FluentAssertions + Moq)\n    - Follow Arrange/Act/Assert structure\n@@ -242,36 +250,28 @@ Run /speckit.verify to validate and complete this task.\n \n ### Invalid Test Patterns\n \n-| Pattern | Example | Why Invalid |\n-|---------|---------|-------------|\n-| Testing constants | `MaxRetries.Should().Be(3)` | Proves nothing about behavior |\n-| Testing inputs | `input.Contains(\"*\").Should().BeTrue()` | Tests the input, not processing |\n-| Testing types exist | `typeof(Service).Should().NotBeNull()` | Compiler guarantees this |\n-| Tautologies | `x.Should().Be(x)` | Always passes |\n-| Testing attributes | `[Fact].Should().Exist()` | Tests metadata, not behavior |\n-\n-### Mandatory Validation Checkpoint\n+> **≡ƒôï See `.specify/memory/invalid-test-patterns.md` for the canonical list.**\n \n-**Γ¢ö Before writing ANY test, answer these questions. If any answer is \"no\", STOP and redesign:**\n+Common invalid patterns include:\n+- Testing constants (`MaxRetries.Should().Be(3)`)\n+- Testing inputs, not processing\n+- Tautologies (`x.Should().Be(x)`)\n+- Recreating framework behavior (testing that `SemaphoreSlim` works)\n \n-1. **Behavioral Scope**: Does this test exercise actual runtime code paths?\n-   - Γ¥î Testing a constant value (`Constant.Should().Be(100)`)\n-   - Γ¥î Testing that a type/method exists\n-   - Γ£à Testing that calling a method produces expected output/side-effects\n+### Mandatory Validation Checkpoint\n \n-2. **Breakage Detection**: If I change the implementation to be WRONG, would this test fail?\n-   - Γ¥î `Constant.Should().Be(100)` ΓÇö changing the constant doesn't break behavior this test would catch\n-   - Γ£à `service.DoThing().Should().ProduceExpectedResult()` ΓÇö breaking DoThing fails the test\n+> **≡ƒôï Full checkpoint details in `.specify/memory/invalid-test-patterns.md`**\n \n-3. **Not a Tautology**: Am I testing the code's behavior, not restating its structure?\n-   - Γ¥î `files.Sum(f => f.Size).Should().Be(files.Sum(f => f.Size))` ΓÇö tests nothing\n-   - Γ£à `command.Execute() ΓåÆ observable output matches expected`\n+**Γ¢ö CHECKPOINT ΓÇö Output these answers BEFORE writing test code:**\n \n-**If you're tempted to test a constant, you MUST test the BEHAVIOR that constant controls instead.**\n+```\n+> Test Validity Check:\n+>   Invokes code under test: [YES/NO] ΓÇö Does this call the actual method/class being tested?\n+>   Breakage detection: [YES/NO] ΓÇö If implementation breaks, does test fail?\n+>   Not a tautology: [YES/NO] ΓÇö Testing behavior, not restating structure?\n+```\n \n-Example transformation:\n-- Γ¥î `ProgressThrottleMs.Should().BeLessOrEqualTo(1000)` ΓÇö tests a number\n-- Γ£à Download a large file, capture progress callback timestamps, verify no gap > 1 second\n+**If any answer is NO, do not proceed. Redesign the test.**\n \n ### Verification Question\n \ndiff --git a/BitPantry.CommandLine.Remote.SignalR.Client/FileTransferService.cs b/BitPantry.CommandLine.Remote.SignalR.Client/FileTransferService.cs\nindex fffd7d6..a61ebe1 100644\n--- a/BitPantry.CommandLine.Remote.SignalR.Client/FileTransferService.cs\n+++ b/BitPantry.CommandLine.Remote.SignalR.Client/FileTransferService.cs\n@@ -54,7 +54,7 @@ namespace BitPantry.CommandLine.Remote.SignalR.Client\n             return Convert.ToHexString(hasher.GetHashAndReset());\n         }\n \n-        public async Task<FileUploadResponse> UploadFile(string filePath, string toFilePath, Func<FileUploadProgress, Task> updateProgressFunc = null, CancellationToken token = default, bool skipIfExists = false)\n+        public virtual async Task<FileUploadResponse> UploadFile(string filePath, string toFilePath, Func<FileUploadProgress, Task> updateProgressFunc = null, CancellationToken token = default, bool skipIfExists = false)\n         {\n             if (_proxy.ConnectionState != ServerProxyConnectionState.Connected)\n                 throw new InvalidOperationException(\"The client is disconnected\");\ndiff --git a/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs b/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs\nindex 680e428..05ef8de 100644\n--- a/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs\n+++ b/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs\n@@ -1073,6 +1073,178 @@ namespace BitPantry.CommandLine.Tests.Remote.SignalR.ClientTests\n \n         #endregion\n \n+        #region Summary Display Tests (UX-030, UX-031, UX-032)\n+\n+        /// <summary>\n+        /// Implements: UX-032\n+        /// When: Some files failed in batch download\n+        /// Then: Summary shows \"[N] of [M] files\" with failure details for each failed file\n+        /// \n+        /// This test invokes DownloadCommand.Execute() with multiple files where some fail,\n+        /// and verifies the summary output includes the partial success count and failure details.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task Execute_SomeFilesFailed_DisplaysPartialSuccessWithFailureDetails()\n+        {\n+            // Arrange - Create 3 files, configure 1 to fail\n+            var serverFiles = new[]\n+            {\n+                new FileInfoEntry(\"file1.txt\", 100, DateTime.Now),\n+                new FileInfoEntry(\"file2.txt\", 200, DateTime.Now),\n+                new FileInfoEntry(\"file3.txt\", 300, DateTime.Now)\n+            };\n+\n+            var response = new EnumerateFilesResponse(Guid.NewGuid().ToString(), serverFiles);\n+            _proxyMock\n+                .Setup(p => p.SendRpcRequest<EnumerateFilesResponse>(\n+                    It.IsAny<EnumerateFilesRequest>(),\n+                    It.IsAny<CancellationToken>()))\n+                .ReturnsAsync(response);\n+            _proxyMock.Setup(p => p.ConnectionState).Returns(ServerProxyConnectionState.Connected);\n+\n+            // Mock FileTransferService - file2.txt will fail\n+            var mockService = TestFileTransferServiceFactory.CreateMock(_proxyMock);\n+            var callCount = 0;\n+            mockService\n+                .Setup(s => s.DownloadFile(\n+                    It.IsAny<string>(),\n+                    It.IsAny<string>(),\n+                    It.IsAny<Func<FileDownloadProgress, Task>>(),\n+                    It.IsAny<CancellationToken>()))\n+                .Returns((string remotePath, string localPath, Func<FileDownloadProgress, Task>? progress, CancellationToken ct) =>\n+                {\n+                    Interlocked.Increment(ref callCount);\n+                    if (remotePath.Contains(\"file2\"))\n+                    {\n+                        throw new IOException(\"Network connection lost\");\n+                    }\n+                    return Task.CompletedTask;\n+                });\n+\n+            var command = new DownloadCommand(\n+                _proxyMock.Object,\n+                mockService.Object,\n+                _console,\n+                _fileSystem);\n+            command.Source = \"*.txt\";\n+            command.Destination = @\"C:\\downloads\\\";\n+\n+            // Act\n+            await command.Execute(CreateContext());\n+\n+            // Assert - Summary should show partial success (2 of 3)\n+            _console.Output.Should().Contain(\"2 of 3\", \"should display partial success count\");\n+            \n+            // Assert - Should show failure details with file path and error message\n+            _console.Output.Should().Contain(\"Failed\", \"should indicate failures occurred\");\n+            _console.Output.Should().Contain(\"file2\", \"should identify the failed file\");\n+            _console.Output.Should().Contain(\"Network connection lost\", \"should include error message\");\n+        }\n+\n+        #endregion\n+\n+        #region Concurrent Download Tests (UX-024)\n+\n+        /// <summary>\n+        /// Implements: UX-024\n+        /// When: User downloads 10 files via glob pattern\n+        /// Then: Maximum DownloadConstants.MaxConcurrentDownloads (4) concurrent transfers active at once\n+        /// \n+        /// This test invokes the actual DownloadCommand.Execute() with 10 files and instruments\n+        /// the mocked FileTransferService.DownloadFile to track concurrent call count.\n+        /// If the SemaphoreSlim is removed or misconfigured, this test will fail.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task Execute_TenFilesViaGlob_LimitsConcurrentDownloadsToMax()\n+        {\n+            // Arrange - Create 10 files that exceed progress threshold to trigger concurrent path\n+            var totalSizePerFile = (DownloadConstants.ProgressDisplayThreshold / 10) + 1024; // Ensure total > threshold\n+            var serverFiles = Enumerable.Range(1, 10)\n+                .Select(i => new FileInfoEntry($\"file{i}.txt\", totalSizePerFile, DateTime.Now))\n+                .ToArray();\n+\n+            var response = new EnumerateFilesResponse(Guid.NewGuid().ToString(), serverFiles);\n+            _proxyMock\n+                .Setup(p => p.SendRpcRequest<EnumerateFilesResponse>(\n+                    It.IsAny<EnumerateFilesRequest>(),\n+                    It.IsAny<CancellationToken>()))\n+                .ReturnsAsync(response);\n+            _proxyMock.Setup(p => p.ConnectionState).Returns(ServerProxyConnectionState.Connected);\n+\n+            // Track concurrent download calls\n+            var concurrentCount = 0;\n+            var maxConcurrentObserved = 0;\n+            var downloadStartedSignal = new SemaphoreSlim(0, 10);\n+            var releaseDownloadsSignal = new SemaphoreSlim(0, 10);\n+\n+            var mockService = TestFileTransferServiceFactory.CreateMock(_proxyMock);\n+            mockService\n+                .Setup(s => s.DownloadFile(\n+                    It.IsAny<string>(),\n+                    It.IsAny<string>(),\n+                    It.IsAny<Func<FileDownloadProgress, Task>>(),\n+                    It.IsAny<CancellationToken>()))\n+                .Returns(async (string remotePath, string localPath, Func<FileDownloadProgress, Task>? progress, CancellationToken ct) =>\n+                {\n+                    // Increment concurrent count and track max\n+                    var current = Interlocked.Increment(ref concurrentCount);\n+                    int observed;\n+                    do\n+                    {\n+                        observed = maxConcurrentObserved;\n+                        if (current <= observed) break;\n+                    } while (Interlocked.CompareExchange(ref maxConcurrentObserved, current, observed) != observed);\n+\n+                    // Signal that we've started\n+                    downloadStartedSignal.Release();\n+\n+                    // Wait until test releases us (simulates download in progress)\n+                    await releaseDownloadsSignal.WaitAsync(ct);\n+\n+                    Interlocked.Decrement(ref concurrentCount);\n+                });\n+\n+            // Create command with mocked service\n+            var command = new DownloadCommand(\n+                _proxyMock.Object,\n+                mockService.Object,\n+                _console,\n+                _fileSystem);\n+            command.Source = \"*.txt\";\n+            command.Destination = @\"C:\\downloads\\\";\n+\n+            // Act - Start command execution in background\n+            var executeTask = Task.Run(async () => await command.Execute(CreateContext()));\n+\n+            // Wait for first batch to start (should be MaxConcurrentDownloads)\n+            for (int i = 0; i < DownloadConstants.MaxConcurrentDownloads; i++)\n+            {\n+                await downloadStartedSignal.WaitAsync();\n+            }\n+\n+            // Give additional time for any extra downloads to incorrectly start\n+            await Task.Delay(100);\n+\n+            // Assert - Only MaxConcurrentDownloads should be active\n+            maxConcurrentObserved.Should().Be(DownloadConstants.MaxConcurrentDownloads,\n+                $\"DownloadCommand should limit concurrent downloads to {DownloadConstants.MaxConcurrentDownloads}\");\n+            concurrentCount.Should().Be(DownloadConstants.MaxConcurrentDownloads,\n+                \"current concurrent count should equal max allowed\");\n+\n+            // Release all downloads to complete the test\n+            releaseDownloadsSignal.Release(10);\n+            await executeTask;\n+\n+            // Verify all 10 downloads were eventually called\n+            mockService.Verify(s => s.DownloadFile(\n+                It.IsAny<string>(),\n+                It.IsAny<string>(),\n+                It.IsAny<Func<FileDownloadProgress, Task>>(),\n+                It.IsAny<CancellationToken>()), Times.Exactly(10));\n+        }\n+\n+        #endregion\n+\n         #region Constants Documentation\n \n         /// <summary>\ndiff --git a/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/UploadCommandTests.cs b/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/UploadCommandTests.cs\nindex 35abafc..30e7911 100644\n--- a/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/UploadCommandTests.cs\n+++ b/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/UploadCommandTests.cs\n@@ -2,6 +2,7 @@ using BitPantry.CommandLine.API;\n using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Component;\n using BitPantry.CommandLine.Processing.Execution;\n+using BitPantry.CommandLine.Remote.SignalR;\n using BitPantry.CommandLine.Remote.SignalR.Client;\n using BitPantry.CommandLine.Remote.SignalR.Client.Commands.Server;\n using BitPantry.CommandLine.Tests.Remote.SignalR.Helpers;\n@@ -372,67 +373,102 @@ namespace BitPantry.CommandLine.Tests.Remote.SignalR.ClientTests\n \n         /// <summary>\n         /// Implements: CV-015\n-        /// Given 10 files with max concurrency 4, only 4 uploads active simultaneously.\n-        /// Tests that SemaphoreSlim correctly limits concurrency.\n+        /// When: User uploads 10 files via glob pattern\n+        /// Then: Maximum UploadConstants.MaxConcurrentUploads (4) concurrent transfers active at once\n+        /// \n+        /// This test invokes the actual UploadCommand.Execute() with 10 files and instruments\n+        /// the mocked FileTransferService.UploadFile to track concurrent call count.\n+        /// If the SemaphoreSlim is removed or misconfigured, this test will fail.\n         /// </summary>\n         [TestMethod]\n-        public async Task UploadMultipleFiles_RespectsMaxConcurrency_Only4Simultaneous()\n+        [Timeout(10000)] // 10 second timeout to catch hangs\n+        public async Task Execute_TenFilesViaGlob_LimitsConcurrentUploadsToMax()\n         {\n-            // Arrange\n-            var concurrentCount = 0;\n-            var maxObserved = 0;\n-            var releaseSignal = new SemaphoreSlim(0, 10);\n-            var enteredSignal = new SemaphoreSlim(0, 10);\n-            \n-            // Create a semaphore that mimics UploadCommand's behavior\n-            var uploadSemaphore = new SemaphoreSlim(UploadConstants.MaxConcurrentUploads);\n+            // Arrange - Create 10 local files BELOW progress threshold to avoid Progress() UI issues\n+            // The semaphore throttling is used regardless of progress display\n+            var tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n+            Directory.CreateDirectory(tempDir);\n             \n-            // Simulate 10 concurrent upload operations\n-            var tasks = Enumerable.Range(0, 10).Select(async i =>\n+            try\n             {\n-                await uploadSemaphore.WaitAsync();\n-                try\n+                // Create 10 small files - total should be BELOW ProgressDisplayThreshold (25MB)\n+                // This ensures we test the semaphore logic without triggering Progress() UI\n+                var fileSizePerFile = 1024; // 1KB per file = 10KB total (well under 25MB)\n+                for (int i = 1; i <= 10; i++)\n                 {\n-                    var current = Interlocked.Increment(ref concurrentCount);\n-                    \n-                    // Track max concurrent\n-                    int observed;\n-                    do\n-                    {\n-                        observed = maxObserved;\n-                        if (current <= observed) break;\n-                    } while (Interlocked.CompareExchange(ref maxObserved, current, observed) != observed);\n-                    \n-                    // Signal that we've entered\n-                    enteredSignal.Release();\n-                    \n-                    // Wait for release signal\n-                    await releaseSignal.WaitAsync();\n-                    \n-                    Interlocked.Decrement(ref concurrentCount);\n-                }\n-                finally\n-                {\n-                    uploadSemaphore.Release();\n+                    var filePath = Path.Combine(tempDir, $\"file{i}.txt\");\n+                    File.WriteAllBytes(filePath, new byte[fileSizePerFile]);\n                 }\n-            }).ToList();\n-            \n-            // Wait for all to enter (up to max concurrency)\n-            for (int i = 0; i < UploadConstants.MaxConcurrentUploads; i++)\n+\n+                // Track concurrent upload calls\n+                var concurrentCount = 0;\n+                var maxConcurrentObserved = 0;\n+                var lockObj = new object();\n+\n+                var mockService = TestFileTransferServiceFactory.CreateMock(_proxyMock);\n+                mockService\n+                    .Setup(s => s.UploadFile(\n+                        It.IsAny<string>(),\n+                        It.IsAny<string>(),\n+                        It.IsAny<Func<FileUploadProgress, Task>>(),\n+                        It.IsAny<CancellationToken>(),\n+                        It.IsAny<bool>()))\n+                    .Returns(async (string localPath, string remotePath, Func<FileUploadProgress, Task>? progress, CancellationToken ct, bool skipIfExists) =>\n+                    {\n+                        // Increment concurrent count and track max\n+                        lock (lockObj)\n+                        {\n+                            concurrentCount++;\n+                            if (concurrentCount > maxConcurrentObserved)\n+                                maxConcurrentObserved = concurrentCount;\n+                        }\n+\n+                        // Simulate upload taking a bit of time\n+                        await Task.Delay(50, ct);\n+\n+                        lock (lockObj)\n+                        {\n+                            concurrentCount--;\n+                        }\n+                        return new FileUploadResponse(\"success\");\n+                    });\n+\n+                // Create command with mocked service and real file system\n+                var command = new UploadCommand(\n+                    _proxyMock.Object,\n+                    mockService.Object,\n+                    _console,\n+                    new FileSystem());\n+                command.Source = Path.Combine(tempDir, \"*.txt\");\n+                command.Destination = \"remote/\";\n+                \n+                // Initialize SkipExisting Option using reflection (constructor is internal)\n+                var optionCtor = typeof(BitPantry.CommandLine.API.Option)\n+                    .GetConstructor(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic, \n+                        null, new[] { typeof(bool) }, null);\n+                command.SkipExisting = (BitPantry.CommandLine.API.Option)optionCtor!.Invoke(new object[] { false });\n+\n+                // Act - Execute the command\n+                await command.Execute(CreateContext());\n+\n+                // Assert - MaxConcurrentUploads should be observed\n+                maxConcurrentObserved.Should().Be(UploadConstants.MaxConcurrentUploads,\n+                    $\"UploadCommand should limit concurrent uploads to {UploadConstants.MaxConcurrentUploads}\");\n+\n+                // Verify all 10 uploads were called\n+                mockService.Verify(s => s.UploadFile(\n+                    It.IsAny<string>(),\n+                    It.IsAny<string>(),\n+                    It.IsAny<Func<FileUploadProgress, Task>>(),\n+                    It.IsAny<CancellationToken>(),\n+                    It.IsAny<bool>()), Times.Exactly(10));\n+            }\n+            finally\n             {\n-                await enteredSignal.WaitAsync();\n+                // Cleanup temp directory\n+                if (Directory.Exists(tempDir))\n+                    Directory.Delete(tempDir, recursive: true);\n             }\n-            \n-            // Give a moment for any additional to try entering\n-            await Task.Delay(50);\n-            \n-            // Assert - only 4 should be in the critical section\n-            concurrentCount.Should().Be(UploadConstants.MaxConcurrentUploads);\n-            maxObserved.Should().Be(UploadConstants.MaxConcurrentUploads);\n-            \n-            // Release all to complete\n-            releaseSignal.Release(10);\n-            await Task.WhenAll(tasks);\n         }\n \n         #endregion\ndiff --git a/specs/007-download-command/batch-state.json b/specs/007-download-command/batch-state.json\nindex d93458c..ce4f382 100644\n--- a/specs/007-download-command/batch-state.json\n+++ b/specs/007-download-command/batch-state.json\n@@ -1,8 +1,8 @@\n {\n   \"featureDir\": \"specs/007-download-command\",\n   \"activeBatch\": \"batch-006\",\n-  \"currentTask\": null,\n-  \"batchStatus\": \"pending\",\n+  \"currentTask\": \"T137\",\n+  \"batchStatus\": \"in-progress\",\n   \"taskStates\": {\n     \"T001\": {\n       \"status\": \"verified\",\n@@ -702,10 +702,13 @@\n       \"phase\": \"verified\"\n     },\n     \"T134\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-14T15:54:46.6443018-06:00\"\n     },\n     \"T137\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"red\",\n+      \"status\": \"in-progress\"\n     },\n     \"T138\": {\n       \"phase\": \"pending\"\ndiff --git a/specs/007-download-command/batches/batch-006.md b/specs/007-download-command/batches/batch-006.md\nindex e03ea3a..ab581b6 100644\n--- a/specs/007-download-command/batches/batch-006.md\n+++ b/specs/007-download-command/batches/batch-006.md\n@@ -1,7 +1,7 @@\n # Batch 006: US5 Implementation + Concurrent Download Tests\n \n **Created**: 2026-01-11\n-**Status**: pending\n+**Status**: in-progress\n **Tasks**: 15\n **Type**: mixed (implementation + backfill)\n \n@@ -41,7 +41,7 @@ US5 concurrent download implementation and all related tests.\n \n ### US5 Tests (Depend on Implementation)\n \n-- [ ] T134 [depends:T145] @test-case:UX-024 Test concurrent download limit in `DownloadCommandTests.cs`\n+- [X] T134 [depends:T145] @test-case:UX-024 Test concurrent download limit in `DownloadCommandTests.cs`\n - [X] T135 [depends:T147] @test-case:UX-025 Test aggregate progress for concurrent downloads in `DownloadCommandTests.cs`\n   > **Already exists**: `IntegrationTests_DownloadCommand.DownloadCommand_MultipleFiles_AggregateAboveThreshold_DisplaysProgressBar` tests aggregate progress with WriteLog.\n - [X] T136 [depends:T149] @test-case:UX-026 Test completion summary shows total count in `DownloadCommandTests.cs`\n@@ -63,3 +63,4 @@ All 15 tasks must be verified via `/speckit.verify` before batch advances.\n \n - Implementation tasks T145-T149 should be done first as tests depend on them\n - T141 depends on T133 (partial file cleanup from Batch 004)\n+"
  }
}
