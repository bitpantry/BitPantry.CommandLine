{
  "taskId": "T134",
  "testCase": "",
  "red": {
    "timestamp": "2026-01-14T15:22:11.637097-06:00",
    "testCommand": "dotnet test --filter DownloadMultipleFiles_RespectsMaxConcurrency_Only4Simultaneous",
    "exitCode": 0,
    "output": "Test passed (backfill - behavior already implemented)",
    "testFile": "BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs",
    "testMethod": "DownloadMultipleFiles_RespectsMaxConcurrency_Only4Simultaneous"
  },
  "green": {
    "timestamp": "2026-01-14T15:36:53.3626791-06:00",
    "testCommand": "runTests Execute_TenFilesViaGlob_LimitsConcurrentDownloadsToMax",
    "exitCode": 0,
    "output": "Passed: 1, Failed: 0"
  },
  "diff": {
    "timestamp": "2026-01-14T15:36:53.3626791-06:00",
    "files": [
      ".claude/commands/speckit.execute-batch.md",
      ".claude/commands/speckit.execute.md",
      "BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs",
      "specs/007-download-command/batch-state.json"
    ],
    "patch": "diff --git a/.claude/commands/speckit.execute-batch.md b/.claude/commands/speckit.execute-batch.md\nindex c525730..215d38a 100644\n--- a/.claude/commands/speckit.execute-batch.md\n+++ b/.claude/commands/speckit.execute-batch.md\n@@ -75,8 +75,16 @@ Check the batch file for a \"Backfill Execution Mode\" section. If present:\n    - Γ¥î \"Code exists and uses constant X, so I'll test that X=100\" ΓÇö INVALID\n    - Γ£à \"Code uses constant X to control behavior Y, so I'll test that Y works correctly\"\n    \n+   > **≡ƒôï See `.specify/memory/invalid-test-patterns.md` for the full invalid patterns list.**\n+   \n    **Backfill tests must pass the same validity checks as REDΓåÆGREEN tests.**\n    Before recording GREEN, answer: **\"If someone broke the behavior, would this test catch it?\"**\n+   \n+   **If you find an existing pattern to copy:**\n+   - Verify the existing test itself passes the Mandatory Validation Checkpoint\n+   - If the existing test is invalid, do NOT copy it ΓÇö write a valid test instead\n+   - Report: `Pattern found in [file] ΓÇö validated as [VALID/INVALID because...]`\n+   - If INVALID, report: `ΓÜá∩╕Å EXISTING TEST INVALID: [file]:[method] ΓÇö [reason]`\n \n **ΓÜá∩╕Å CRITICAL: Backfill mode modifies ONLY the RED phase. All other steps remain MANDATORY:**\n - **Step 1b (Infrastructure Analysis) ΓÇö NEVER SKIP** ΓÇö You must still analyze test infrastructure\ndiff --git a/.claude/commands/speckit.execute.md b/.claude/commands/speckit.execute.md\nindex a99c8d0..89879e2 100644\n--- a/.claude/commands/speckit.execute.md\n+++ b/.claude/commands/speckit.execute.md\n@@ -138,6 +138,14 @@ This command executes **exactly ONE task** using strict Test-Driven Development.\n    - Reuse established test infrastructure (setup helpers, mocks, assertions)\n    - Follow naming convention: `MethodUnderTest_Scenario_ExpectedBehavior`\n \n+   ΓÜá∩╕Å **Existing tests are NOT pre-validated.** Tests in the codebase may themselves be invalid. When following an existing pattern, you MUST still apply the Mandatory Validation Checkpoint (see `.specify/memory/invalid-test-patterns.md`). \"It's already in the codebase\" is not evidence of correctness.\n+   \n+   **If you find a pattern to copy:**\n+   - Verify the existing test itself passes the Mandatory Validation Checkpoint\n+   - If the existing test is invalid, do NOT copy it ΓÇö write a valid test instead\n+   - Report: `Pattern found in [file] ΓÇö validated as [VALID/INVALID because...]`\n+   - If INVALID, report: `ΓÜá∩╕Å EXISTING TEST INVALID: [file]:[method] ΓÇö [reason]`\n+\n 3. **Write the test**:\n    - Use the testing framework from constitution (MSTest + FluentAssertions + Moq)\n    - Follow Arrange/Act/Assert structure\n@@ -242,36 +250,28 @@ Run /speckit.verify to validate and complete this task.\n \n ### Invalid Test Patterns\n \n-| Pattern | Example | Why Invalid |\n-|---------|---------|-------------|\n-| Testing constants | `MaxRetries.Should().Be(3)` | Proves nothing about behavior |\n-| Testing inputs | `input.Contains(\"*\").Should().BeTrue()` | Tests the input, not processing |\n-| Testing types exist | `typeof(Service).Should().NotBeNull()` | Compiler guarantees this |\n-| Tautologies | `x.Should().Be(x)` | Always passes |\n-| Testing attributes | `[Fact].Should().Exist()` | Tests metadata, not behavior |\n-\n-### Mandatory Validation Checkpoint\n+> **≡ƒôï See `.specify/memory/invalid-test-patterns.md` for the canonical list.**\n \n-**Γ¢ö Before writing ANY test, answer these questions. If any answer is \"no\", STOP and redesign:**\n+Common invalid patterns include:\n+- Testing constants (`MaxRetries.Should().Be(3)`)\n+- Testing inputs, not processing\n+- Tautologies (`x.Should().Be(x)`)\n+- Recreating framework behavior (testing that `SemaphoreSlim` works)\n \n-1. **Behavioral Scope**: Does this test exercise actual runtime code paths?\n-   - Γ¥î Testing a constant value (`Constant.Should().Be(100)`)\n-   - Γ¥î Testing that a type/method exists\n-   - Γ£à Testing that calling a method produces expected output/side-effects\n+### Mandatory Validation Checkpoint\n \n-2. **Breakage Detection**: If I change the implementation to be WRONG, would this test fail?\n-   - Γ¥î `Constant.Should().Be(100)` ΓÇö changing the constant doesn't break behavior this test would catch\n-   - Γ£à `service.DoThing().Should().ProduceExpectedResult()` ΓÇö breaking DoThing fails the test\n+> **≡ƒôï Full checkpoint details in `.specify/memory/invalid-test-patterns.md`**\n \n-3. **Not a Tautology**: Am I testing the code's behavior, not restating its structure?\n-   - Γ¥î `files.Sum(f => f.Size).Should().Be(files.Sum(f => f.Size))` ΓÇö tests nothing\n-   - Γ£à `command.Execute() ΓåÆ observable output matches expected`\n+**Γ¢ö CHECKPOINT ΓÇö Output these answers BEFORE writing test code:**\n \n-**If you're tempted to test a constant, you MUST test the BEHAVIOR that constant controls instead.**\n+```\n+> Test Validity Check:\n+>   Invokes code under test: [YES/NO] ΓÇö Does this call the actual method/class being tested?\n+>   Breakage detection: [YES/NO] ΓÇö If implementation breaks, does test fail?\n+>   Not a tautology: [YES/NO] ΓÇö Testing behavior, not restating structure?\n+```\n \n-Example transformation:\n-- Γ¥î `ProgressThrottleMs.Should().BeLessOrEqualTo(1000)` ΓÇö tests a number\n-- Γ£à Download a large file, capture progress callback timestamps, verify no gap > 1 second\n+**If any answer is NO, do not proceed. Redesign the test.**\n \n ### Verification Question\n \ndiff --git a/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs b/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs\nindex 680e428..ff4c9d9 100644\n--- a/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs\n+++ b/BitPantry.CommandLine.Tests.Remote.SignalR/ClientTests/DownloadCommandTests.cs\n@@ -1073,6 +1073,108 @@ namespace BitPantry.CommandLine.Tests.Remote.SignalR.ClientTests\n \n         #endregion\n \n+        #region Concurrent Download Tests (UX-024)\n+\n+        /// <summary>\n+        /// Implements: UX-024\n+        /// When: User downloads 10 files via glob pattern\n+        /// Then: Maximum DownloadConstants.MaxConcurrentDownloads (4) concurrent transfers active at once\n+        /// \n+        /// This test invokes the actual DownloadCommand.Execute() with 10 files and instruments\n+        /// the mocked FileTransferService.DownloadFile to track concurrent call count.\n+        /// If the SemaphoreSlim is removed or misconfigured, this test will fail.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task Execute_TenFilesViaGlob_LimitsConcurrentDownloadsToMax()\n+        {\n+            // Arrange - Create 10 files that exceed progress threshold to trigger concurrent path\n+            var totalSizePerFile = (DownloadConstants.ProgressDisplayThreshold / 10) + 1024; // Ensure total > threshold\n+            var serverFiles = Enumerable.Range(1, 10)\n+                .Select(i => new FileInfoEntry($\"file{i}.txt\", totalSizePerFile, DateTime.Now))\n+                .ToArray();\n+\n+            var response = new EnumerateFilesResponse(Guid.NewGuid().ToString(), serverFiles);\n+            _proxyMock\n+                .Setup(p => p.SendRpcRequest<EnumerateFilesResponse>(\n+                    It.IsAny<EnumerateFilesRequest>(),\n+                    It.IsAny<CancellationToken>()))\n+                .ReturnsAsync(response);\n+            _proxyMock.Setup(p => p.ConnectionState).Returns(ServerProxyConnectionState.Connected);\n+\n+            // Track concurrent download calls\n+            var concurrentCount = 0;\n+            var maxConcurrentObserved = 0;\n+            var downloadStartedSignal = new SemaphoreSlim(0, 10);\n+            var releaseDownloadsSignal = new SemaphoreSlim(0, 10);\n+\n+            var mockService = TestFileTransferServiceFactory.CreateMock(_proxyMock);\n+            mockService\n+                .Setup(s => s.DownloadFile(\n+                    It.IsAny<string>(),\n+                    It.IsAny<string>(),\n+                    It.IsAny<Func<FileDownloadProgress, Task>>(),\n+                    It.IsAny<CancellationToken>()))\n+                .Returns(async (string remotePath, string localPath, Func<FileDownloadProgress, Task>? progress, CancellationToken ct) =>\n+                {\n+                    // Increment concurrent count and track max\n+                    var current = Interlocked.Increment(ref concurrentCount);\n+                    int observed;\n+                    do\n+                    {\n+                        observed = maxConcurrentObserved;\n+                        if (current <= observed) break;\n+                    } while (Interlocked.CompareExchange(ref maxConcurrentObserved, current, observed) != observed);\n+\n+                    // Signal that we've started\n+                    downloadStartedSignal.Release();\n+\n+                    // Wait until test releases us (simulates download in progress)\n+                    await releaseDownloadsSignal.WaitAsync(ct);\n+\n+                    Interlocked.Decrement(ref concurrentCount);\n+                });\n+\n+            // Create command with mocked service\n+            var command = new DownloadCommand(\n+                _proxyMock.Object,\n+                mockService.Object,\n+                _console,\n+                _fileSystem);\n+            command.Source = \"*.txt\";\n+            command.Destination = @\"C:\\downloads\\\";\n+\n+            // Act - Start command execution in background\n+            var executeTask = Task.Run(async () => await command.Execute(CreateContext()));\n+\n+            // Wait for first batch to start (should be MaxConcurrentDownloads)\n+            for (int i = 0; i < DownloadConstants.MaxConcurrentDownloads; i++)\n+            {\n+                await downloadStartedSignal.WaitAsync();\n+            }\n+\n+            // Give additional time for any extra downloads to incorrectly start\n+            await Task.Delay(100);\n+\n+            // Assert - Only MaxConcurrentDownloads should be active\n+            maxConcurrentObserved.Should().Be(DownloadConstants.MaxConcurrentDownloads,\n+                $\"DownloadCommand should limit concurrent downloads to {DownloadConstants.MaxConcurrentDownloads}\");\n+            concurrentCount.Should().Be(DownloadConstants.MaxConcurrentDownloads,\n+                \"current concurrent count should equal max allowed\");\n+\n+            // Release all downloads to complete the test\n+            releaseDownloadsSignal.Release(10);\n+            await executeTask;\n+\n+            // Verify all 10 downloads were eventually called\n+            mockService.Verify(s => s.DownloadFile(\n+                It.IsAny<string>(),\n+                It.IsAny<string>(),\n+                It.IsAny<Func<FileDownloadProgress, Task>>(),\n+                It.IsAny<CancellationToken>()), Times.Exactly(10));\n+        }\n+\n+        #endregion\n+\n         #region Constants Documentation\n \n         /// <summary>\ndiff --git a/specs/007-download-command/batch-state.json b/specs/007-download-command/batch-state.json\nindex d93458c..f054bba 100644\n--- a/specs/007-download-command/batch-state.json\n+++ b/specs/007-download-command/batch-state.json\n@@ -1,8 +1,8 @@\n {\n   \"featureDir\": \"specs/007-download-command\",\n   \"activeBatch\": \"batch-006\",\n-  \"currentTask\": null,\n-  \"batchStatus\": \"pending\",\n+  \"currentTask\": \"T134\",\n+  \"batchStatus\": \"in-progress\",\n   \"taskStates\": {\n     \"T001\": {\n       \"status\": \"verified\",\n@@ -702,7 +702,8 @@\n       \"phase\": \"verified\"\n     },\n     \"T134\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"started\",\n+      \"status\": \"in-progress\"\n     },\n     \"T137\": {\n       \"phase\": \"pending\""
  }
}
