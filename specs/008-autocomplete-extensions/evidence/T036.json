{
  "taskId": "T036",
  "testCase": "",
  "green": {
    "timestamp": "2026-01-21T16:58:34.7238380-06:00",
    "testCommand": "",
    "exitCode": -1,
    "output": ""
  },
  "diff": {
    "timestamp": "2026-01-21T16:58:34.7238380-06:00",
    "files": [
      ".claude/commands/speckit.execute.md",
      ".claude/commands/speckit.verify.md",
      "BitPantry.CommandLine.Remote.SignalR.Client/SignalRServerProxy.cs",
      "BitPantry.CommandLine.Remote.SignalR.Server/Configuration/IServiceCollectionExtensions.cs",
      "BitPantry.CommandLine.Remote.SignalR.Server/ServerLogic.cs",
      "BitPantry.CommandLine.Remote.SignalR/Envelopes/AutoCompleteRequest.cs",
      "BitPantry.CommandLine.Tests/AutoComplete/Handlers/AutoCompleteHandlerRegistryTests.cs",
      "BitPantry.CommandLine.Tests/AutoComplete/Handlers/BooleanAutoCompleteHandlerTests.cs",
      "BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs",
      "BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Alias.cs",
      "BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_ArgName.cs",
      "BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_CommandName.cs",
      "BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Groups.cs",
      "BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Positional.cs",
      "BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Value.cs",
      "BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithArgAc.cs",
      "BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithTwoArgAc.cs",
      "BitPantry.CommandLine.Tests/Commands/PositionalCommands/PositionalWithAutoCompleteCommand.cs",
      "BitPantry.CommandLine/API/ArgumentAttribute.cs",
      "BitPantry.CommandLine/AutoComplete/AutoCompleteContext.cs",
      "BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSetBuilder.cs",
      "BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistry.cs",
      "BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistryBuilder.cs",
      "BitPantry.CommandLine/AutoComplete/Handlers/BooleanAutoCompleteHandler.cs",
      "BitPantry.CommandLine/AutoComplete/Handlers/HandlerActivator.cs",
      "BitPantry.CommandLine/AutoComplete/Handlers/IAutoCompleteHandlerRegistry.cs",
      "BitPantry.CommandLine/Client/IServerProxy.cs",
      "BitPantry.CommandLine/Client/NoopServerProxy.cs",
      "BitPantry.CommandLine/CommandLineApplicationBuilder.cs",
      "BitPantry.CommandLine/Component/ArgumentInfo.cs",
      "BitPantry.CommandLine/Processing/Description/CommandReflection.cs",
      "specs/008-autocomplete-extensions/batch-state.json",
      "specs/008-autocomplete-extensions/batches/batch-003.md",
      "specs/008-autocomplete-extensions/handler-registry-freeze-impl-backlog.md"
    ],
    "patch": "diff --git a/.claude/commands/speckit.execute.md b/.claude/commands/speckit.execute.md\nindex 5ee2a27..597e553 100644\n--- a/.claude/commands/speckit.execute.md\n+++ b/.claude/commands/speckit.execute.md\n@@ -1,6 +1,6 @@\n ```markdown\n ---\n-description: Execute exactly ONE task from the active batch using strict redΓåÆgreen TDD loop.\n+description: Execute exactly ONE task from the active batch using strict redΓåÆgreen TDD loop (or implementation-only for tasks without test cases).\n handoffs:\n   - label: Verify Task\n     agent: speckit.verify\n@@ -23,13 +23,21 @@ If empty, execute the next eligible task from the active batch.\n \n ## Intent\n \n-This command executes **exactly ONE task** using strict Test-Driven Development. The agent:\n+This command executes **exactly ONE task**. The execution mode depends on whether the task has a `@test-case` reference:\n+\n+**With `@test-case`** ΓÇö Full TDD cycle:\n 1. Writes a failing test (RED)\n 2. Captures evidence of failure\n 3. Implements minimal code to pass (GREEN)\n 4. Captures evidence of success\n 5. STOPS\n \n+**Without `@test-case`** ΓÇö Implementation-only:\n+1. Implements the described change\n+2. Runs existing tests to ensure no regressions\n+3. Captures evidence of completion (diff)\n+4. STOPS\n+\n **No batch-wide execution. No \"let me do a few more.\" One task, then stop.**\n \n ---\n@@ -59,12 +67,59 @@ This command executes **exactly ONE task** using strict Test-Driven Development.\n \n 1. Read the task details from the script output:\n    - Task ID (e.g., `T005`)\n-   - Test case reference (e.g., `@test-case:UX-003`)\n+   - Test case reference (e.g., `@test-case:UX-003`) ΓÇö **may be null for implementation-only tasks**\n    - Task description with file path\n    - Dependencies (already satisfied if task is eligible)\n \n-2. Load supporting context:\n-   - `test-cases.md`: Find the test case's \"When X, Then Y\" definition\n+2. **Determine execution mode**:\n+   - **If `testCase` is present**: Follow full TDD cycle (Steps 1a ΓåÆ 1b ΓåÆ 2 ΓåÆ 3 ΓåÆ 4)\n+   - **If `testCase` is null**: Skip to **Implementation-Only Mode** (below)\n+\n+3. Load supporting context:\n+   - `test-cases.md`: Find the test case's \"When X, Then Y\" definition (skip if no test case)\n+   - `plan.md`: Understand technical approach and file structure\n+   - `.specify/memory/constitution.md`: Review testing standards\n+\n+4. Run `.specify/scripts/powershell/record-task-phase.ps1 -TaskId T### -Phase started` to mark task as in-progress.\n+\n+---\n+\n+### Implementation-Only Mode (No Test Case)\n+\n+**For tasks WITHOUT a `@test-case` reference, skip the TDD cycle and implement directly.**\n+\n+1. **Understand the task**: Read the description carefully. These are typically:\n+   - Infrastructure/setup tasks\n+   - Registration/wiring tasks\n+   - Configuration changes\n+   - Refactoring that doesn't change behavior\n+\n+2. **Implement the change**: Make the described modification.\n+\n+3. **Run regression tests**: Ensure existing tests still pass:\n+   ```powershell\n+   dotnet test [relevant-test-project]\n+   ```\n+\n+4. **Record completion**:\n+   ```powershell\n+   .specify/scripts/powershell/record-task-phase.ps1 -TaskId T### -Phase green -TestCommand \"dotnet test\" -ExitCode 0 -TestOutput \"All tests passed\"\n+   ```\n+\n+5. **Report and STOP**:\n+   ```\n+   Task T### ready for verification.\n+   \n+   Implementation-only task (no test case).\n+   - Files changed: [list files]\n+   - Regression tests: Passed\n+   \n+   Run /speckit.verify to validate and complete this task.\n+   ```\n+\n+**Then proceed to Step 4: STOP.**\n+\n+---\n    - `plan.md`: Understand technical approach and file structure\n    - `.specify/memory/constitution.md`: Review testing standards\n \ndiff --git a/.claude/commands/speckit.verify.md b/.claude/commands/speckit.verify.md\nindex f39d466..84c7341 100644\n--- a/.claude/commands/speckit.verify.md\n+++ b/.claude/commands/speckit.verify.md\n@@ -31,11 +31,17 @@ If empty, verify the current task from `batch-state.json`.\n ## Intent\n \n This command is a **mandatory gate** between task execution and completion. It validates that:\n+\n+**For TDD tasks (with `@test-case`):**\n 1. The RED phase was properly recorded (test failed)\n 2. The GREEN phase was properly recorded (test passed)\n 3. The sequence is valid (RED before GREEN)\n 4. Implementation changes were captured (diff exists)\n \n+**For implementation-only tasks (without `@test-case`):**\n+1. The GREEN phase was recorded (regression tests passed)\n+2. Implementation changes were captured (diff exists)\n+\n **No task can be marked complete without passing verification.**\n \n ---\n@@ -63,7 +69,7 @@ This command is a **mandatory gate** between task execution and completion. It v\n \n Run `.specify/scripts/powershell/check-task-evidence.ps1 -TaskId T### -Json`\n \n-The script validates:\n+**For TDD tasks (with `@test-case`)**, the script validates:\n \n | Check | Pass Criteria | Failure Code |\n |-------|---------------|--------------|\n@@ -76,6 +82,18 @@ The script validates:\n | Files changed | `diff.files` is non-empty | `NO_CHANGES` |\n | Valid sequence | `green.timestamp > red.timestamp` | `INVALID_SEQUENCE` |\n \n+**For implementation-only tasks (without `@test-case`)**, relaxed validation:\n+\n+| Check | Pass Criteria | Failure Code |\n+|-------|---------------|--------------|\n+| Evidence file exists | `evidence/T###.json` exists | `MISSING_EVIDENCE` |\n+| GREEN section exists | `green` object present | `MISSING_GREEN` |\n+| GREEN shows success | `green.exitCode == 0` | `GREEN_FAILED` |\n+| Diff section exists | `diff` object present | `MISSING_DIFF` |\n+| Files changed | `diff.files` is non-empty | `NO_CHANGES` |\n+\n+**Note**: RED phase is NOT required for implementation-only tasks.\n+\n ### Step 2: Handle Validation Result\n \n **If ALL checks pass:**\ndiff --git a/BitPantry.CommandLine.Remote.SignalR.Client/SignalRServerProxy.cs b/BitPantry.CommandLine.Remote.SignalR.Client/SignalRServerProxy.cs\nindex 0a9069b..4a5a4ca 100644\n--- a/BitPantry.CommandLine.Remote.SignalR.Client/SignalRServerProxy.cs\n+++ b/BitPantry.CommandLine.Remote.SignalR.Client/SignalRServerProxy.cs\n@@ -1,5 +1,6 @@\n ∩╗┐using BitPantry.CommandLine.AutoComplete;\n using BitPantry.CommandLine.Client;\n+using HandlerContext = BitPantry.CommandLine.AutoComplete.Handlers.AutoCompleteContext;\n using BitPantry.CommandLine.Processing.Execution;\n using BitPantry.CommandLine.Remote.SignalR.Envelopes;\n using BitPantry.CommandLine.Remote.SignalR.Rpc;\n@@ -258,13 +259,11 @@ namespace BitPantry.CommandLine.Remote.SignalR.Client\n         /// </summary>\n         /// <param name=\"groupPath\">The target command group path (space-separated)</param>\n         /// <param name=\"cmdName\">The target command name</param>\n-        /// <param name=\"functionName\">The command's auto complete function name</param>\n-        /// <param name=\"isFunctionAsync\">True if the auto complete function can be executed asynchronously, otherwise false</param>\n-        /// <param name=\"ctx\">The <see cref=\"AutoCompleteContext\"/></param>\n+        /// <param name=\"ctx\">The handler context</param>\n         /// <param name=\"token\">A cancellation token</param>\n         /// <returns></returns>\n         /// <exception cref=\"InvalidOperationException\"></exception>\n-        public async Task<List<AutoCompleteOption>> AutoComplete(string groupPath, string cmdName, string functionName, bool isFunctionAsync, AutoCompleteContext ctx, CancellationToken token = default)\n+        public async Task<List<AutoCompleteOption>> AutoComplete(string groupPath, string cmdName, HandlerContext ctx, CancellationToken token = default)\n         {\n             using (await _gate.LockAsync(_activeOpLockName))\n             {\n@@ -275,7 +274,7 @@ namespace BitPantry.CommandLine.Remote.SignalR.Client\n \n                 // send the request\n \n-                var resp = await _connection.Rpc<AutoCompleteResponse>(_rpcMsgReg, new AutoCompleteRequest(groupPath, cmdName, functionName, isFunctionAsync, ctx), token);\n+                var resp = await _connection.Rpc<AutoCompleteResponse>(_rpcMsgReg, new AutoCompleteRequest(groupPath, cmdName, ctx), token);\n \n                 return resp.Results;\n             }\ndiff --git a/BitPantry.CommandLine.Remote.SignalR.Server/Configuration/IServiceCollectionExtensions.cs b/BitPantry.CommandLine.Remote.SignalR.Server/Configuration/IServiceCollectionExtensions.cs\nindex 0dbd189..89ab58b 100644\n--- a/BitPantry.CommandLine.Remote.SignalR.Server/Configuration/IServiceCollectionExtensions.cs\n+++ b/BitPantry.CommandLine.Remote.SignalR.Server/Configuration/IServiceCollectionExtensions.cs\n@@ -1,4 +1,5 @@\n-∩╗┐using BitPantry.CommandLine.Remote.SignalR.Rpc;\n+∩╗┐using BitPantry.CommandLine.AutoComplete.Handlers;\n+using BitPantry.CommandLine.Remote.SignalR.Rpc;\n using BitPantry.CommandLine.Remote.SignalR.Server.Files;\n using BitPantry.CommandLine.Remote.SignalR.Server.Rpc;\n using Microsoft.AspNetCore.Builder;\n@@ -96,6 +97,10 @@ namespace BitPantry.CommandLine.Remote.SignalR.Server.Configuration\n             // Build the immutable registry from the builder (also registers command types with DI)\n             var commandRegistry = opt.CommandRegistryBuilder.Build(services);\n \n+            // Build the autocomplete handler registry (registers handlers with DI)\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerBuilder.Build(services);\n+\n             // Register IFileSystem as SandboxedFileSystem for command execution\n             // Commands inject IFileSystem and get sandboxed access to StorageRootPath\n             services.AddScoped<IFileSystem>(sp =>\n@@ -114,6 +119,8 @@ namespace BitPantry.CommandLine.Remote.SignalR.Server.Configuration\n \n             services.AddSingleton<ICommandRegistry>(commandRegistry);\n \n+            services.AddSingleton<IAutoCompleteHandlerRegistry>(handlerRegistry);\n+\n             services.AddScoped<ServerLogic>();\n \n             services.AddScoped<RpcMessageRegistry>();\ndiff --git a/BitPantry.CommandLine.Remote.SignalR.Server/ServerLogic.cs b/BitPantry.CommandLine.Remote.SignalR.Server/ServerLogic.cs\nindex fb62ab7..aee1fba 100644\n--- a/BitPantry.CommandLine.Remote.SignalR.Server/ServerLogic.cs\n+++ b/BitPantry.CommandLine.Remote.SignalR.Server/ServerLogic.cs\n@@ -1,4 +1,5 @@\n ∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Help;\n using BitPantry.CommandLine.Processing.Activation;\n@@ -24,14 +25,16 @@ namespace BitPantry.CommandLine.Remote.SignalR.Server\n         private ILogger<ServerLogic> _logger;\n         private IServiceProvider _serviceProvider;\n         private ICommandRegistry _commandReg;\n+        private IAutoCompleteHandlerRegistry _handlerRegistry;\n         private RpcMessageRegistry _rpcMsgReg;\n         private FileTransferOptions _fileTransferOptions;\n \n-        public ServerLogic(ILogger<ServerLogic> logger, IServiceProvider serviceProvider, ICommandRegistry commandReg, RpcMessageRegistry rpcMsgReg, FileTransferOptions fileTransferOptions)\n+        public ServerLogic(ILogger<ServerLogic> logger, IServiceProvider serviceProvider, ICommandRegistry commandReg, IAutoCompleteHandlerRegistry handlerRegistry, RpcMessageRegistry rpcMsgReg, FileTransferOptions fileTransferOptions)\n         {\n             _logger = logger;\n             _serviceProvider = serviceProvider;\n             _commandReg = commandReg;\n+            _handlerRegistry = handlerRegistry;\n             _rpcMsgReg = rpcMsgReg;\n             _fileTransferOptions = fileTransferOptions;\n         }\n@@ -117,28 +120,25 @@ namespace BitPantry.CommandLine.Remote.SignalR.Server\n             ArgumentNullException.ThrowIfNull(proxy);\n             ArgumentNullException.ThrowIfNull(req);\n \n-            // instantiate the command and execute the auto complete function\n-            // Use the FullyQualifiedName format (space-separated groupPath + name)\n-            var fullyQualifiedName = string.IsNullOrEmpty(req.GroupPath) \n-                ? req.CmdName \n-                : $\"{req.GroupPath} {req.CmdName}\";\n-            var cmdInfo = _commandReg.Find(fullyQualifiedName);\n-            \n-            using var scope = _serviceProvider.CreateScope();\n-            var cmd = scope.ServiceProvider.GetRequiredService(cmdInfo.Type);\n-            var method = cmdInfo.Type.GetMethod(req.FunctionName);\n-\n-            if (method is null)\n-                throw new NullReferenceException($\"The function name, {req.FunctionName}, could not be resolved to a function on type, {cmdInfo.Type}\");\n-\n-            var args = new[] { req.Context };\n+            var activator = new AutoCompleteHandlerActivator(_serviceProvider);\n \n-            var results = await (req.IsFunctionAsync\n-                    ? (Task<List<AutoCompleteOption>>)method.Invoke(cmd, args)\n-                    : Task.Factory.StartNew(() => (List<AutoCompleteOption>)method.Invoke(cmd, args)));\n+            // Find the handler for this argument\n+            var handlerType = _handlerRegistry.FindHandler(req.Context.ArgumentInfo, activator);\n+            \n+            List<AutoCompleteOption> results;\n+            if (handlerType == null)\n+            {\n+                // No handler found - return empty results\n+                results = new List<AutoCompleteOption>();\n+            }\n+            else\n+            {\n+                // Activate and invoke the handler (scope disposed after use)\n+                using var activation = activator.Activate(handlerType);\n+                results = await activation.Handler.GetOptionsAsync(req.Context);\n+            }\n \n             // return response\n-\n             await proxy.SendAsync(SignalRMethodNames.ReceiveResponse, new AutoCompleteResponse(req.CorrelationId, results));\n         }\n \ndiff --git a/BitPantry.CommandLine.Remote.SignalR/Envelopes/AutoCompleteRequest.cs b/BitPantry.CommandLine.Remote.SignalR/Envelopes/AutoCompleteRequest.cs\nindex 46d0d8d..b5de915 100644\n--- a/BitPantry.CommandLine.Remote.SignalR/Envelopes/AutoCompleteRequest.cs\n+++ b/BitPantry.CommandLine.Remote.SignalR/Envelopes/AutoCompleteRequest.cs\n@@ -1,4 +1,5 @@\n ∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n using System.Text.Json.Serialization;\n \n namespace BitPantry.CommandLine.Remote.SignalR.Envelopes\n@@ -19,20 +20,6 @@ namespace BitPantry.CommandLine.Remote.SignalR.Envelopes\n             set { Data[MessageArgNames.AutoCompleteRequest.CmdName] = value; }\n         }\n \n-        [JsonIgnore]\n-        public string FunctionName\n-        {\n-            get { return Data[MessageArgNames.AutoCompleteRequest.FunctionName]; }\n-            set { Data[MessageArgNames.AutoCompleteRequest.FunctionName] = value; }\n-        }\n-\n-        [JsonIgnore]\n-        public bool IsFunctionAsync\n-        {\n-            get { return ParseString<bool>(MessageArgNames.AutoCompleteRequest.IsFunctionAsync); }\n-            set { Data[MessageArgNames.AutoCompleteRequest.IsFunctionAsync] = value.ToString(); }\n-        }\n-\n         [JsonIgnore]\n         public AutoCompleteContext Context\n         {\n@@ -42,13 +29,11 @@ namespace BitPantry.CommandLine.Remote.SignalR.Envelopes\n \n         public AutoCompleteRequest(Dictionary<string, string> data) : base(data) { }\n \n-        public AutoCompleteRequest(string groupPath, string cmdName, string functionName, bool isFunctionAsync, AutoCompleteContext ctx) : this([])\n+        public AutoCompleteRequest(string groupPath, string cmdName, AutoCompleteContext ctx) : this([])\n         {\n             GroupPath = groupPath;\n             CmdName = cmdName;\n             RequestType = ServerRequestType.AutoComplete;\n-            FunctionName = functionName;\n-            IsFunctionAsync = isFunctionAsync;\n             Context = ctx;\n         }\n     }\ndiff --git a/BitPantry.CommandLine.Tests/AutoComplete/Handlers/AutoCompleteHandlerRegistryTests.cs b/BitPantry.CommandLine.Tests/AutoComplete/Handlers/AutoCompleteHandlerRegistryTests.cs\nindex 73f5f23..dca269a 100644\n--- a/BitPantry.CommandLine.Tests/AutoComplete/Handlers/AutoCompleteHandlerRegistryTests.cs\n+++ b/BitPantry.CommandLine.Tests/AutoComplete/Handlers/AutoCompleteHandlerRegistryTests.cs\n@@ -26,19 +26,21 @@ public class AutoCompleteHandlerRegistryTests\n     /// <summary>\n     /// Implements: 008:TC-1.1\n     /// Register adds handler to the list, verified after build.\n+    /// Note: Builder starts with 2 built-in handlers (EnumAutoCompleteHandler, BooleanAutoCompleteHandler).\n     /// </summary>\n     [TestMethod]\n     public void Register_WithValidHandler_AddsToRegistry()\n     {\n         // Arrange\n         var builder = new AutoCompleteHandlerRegistryBuilder();\n+        // Builder includes 2 built-in handlers by default\n \n         // Act\n         builder.Register<TestTypeHandler>();\n         var registry = builder.Build();\n \n-        // Assert\n-        registry.TypeHandlerCount.Should().Be(1);\n+        // Assert - 2 built-in + 1 registered = 3\n+        registry.TypeHandlerCount.Should().Be(3);\n     }\n \n     /// <summary>\n@@ -54,7 +56,7 @@ public class AutoCompleteHandlerRegistryTests\n         builder.Register<TestTypeHandler>();\n         var registry = builder.Build(services);\n         var serviceProvider = services.BuildServiceProvider();\n-        var activator = new HandlerActivator(serviceProvider);\n+        var activator = new AutoCompleteHandlerActivator(serviceProvider);\n         \n         // Get an ArgumentInfo for int (which TestTypeHandler does NOT handle)\n         var commandInfo = CommandReflection.Describe<TestCommandWithIntArg>();\n@@ -81,7 +83,7 @@ public class AutoCompleteHandlerRegistryTests\n         builder.Register<EnumHandlerB>();\n         var registry = builder.Build(services);\n         var serviceProvider = services.BuildServiceProvider();\n-        var activator = new HandlerActivator(serviceProvider);\n+        var activator = new AutoCompleteHandlerActivator(serviceProvider);\n         \n         // Get an ArgumentInfo for LogLevel enum\n         var commandInfo = CommandReflection.Describe<TestCommandWithLogLevel>();\n@@ -95,8 +97,8 @@ public class AutoCompleteHandlerRegistryTests\n         handlerType.Should().Be(typeof(EnumHandlerB));\n         \n         // Verify activation works\n-        var handler = activator.Activate(handlerType!);\n-        handler.Should().BeOfType<EnumHandlerB>();\n+        using var activation = activator.Activate(handlerType!);\n+        activation.Handler.Should().BeOfType<EnumHandlerB>();\n     }\n \n     /// <summary>\n@@ -113,7 +115,7 @@ public class AutoCompleteHandlerRegistryTests\n         builder.Register<EnumHandlerA>();  // Type handler registered\n         var registry = builder.Build(services);\n         var serviceProvider = services.BuildServiceProvider();\n-        var activator = new HandlerActivator(serviceProvider);\n+        var activator = new AutoCompleteHandlerActivator(serviceProvider);\n         \n         // Get an ArgumentInfo for enum WITH [AutoComplete<CustomEnumHandler>] attribute\n         var commandInfo = CommandReflection.Describe<TestCommandWithAttributeHandler>();\n@@ -127,8 +129,8 @@ public class AutoCompleteHandlerRegistryTests\n         handlerType.Should().Be(typeof(CustomEnumHandler));\n         \n         // Verify activation works\n-        var handler = activator.Activate(handlerType!);\n-        handler.Should().BeOfType<CustomEnumHandler>();\n+        using var activation = activator.Activate(handlerType!);\n+        activation.Handler.Should().BeOfType<CustomEnumHandler>();\n     }\n \n     /// <summary>\ndiff --git a/BitPantry.CommandLine.Tests/AutoComplete/Handlers/BooleanAutoCompleteHandlerTests.cs b/BitPantry.CommandLine.Tests/AutoComplete/Handlers/BooleanAutoCompleteHandlerTests.cs\nindex 192498b..b38b5e9 100644\n--- a/BitPantry.CommandLine.Tests/AutoComplete/Handlers/BooleanAutoCompleteHandlerTests.cs\n+++ b/BitPantry.CommandLine.Tests/AutoComplete/Handlers/BooleanAutoCompleteHandlerTests.cs\n@@ -71,6 +71,25 @@ public class BooleanAutoCompleteHandlerTests\n         options.Select(o => o.Value).Should().ContainInOrder(\"false\", \"true\");\n     }\n \n+    /// <summary>\n+    /// Implements: 008:TC-2.11\n+    /// GetOptionsAsync filters by prefix.\n+    /// </summary>\n+    [TestMethod]\n+    public async Task GetOptionsAsync_QueryWithPrefix_FiltersResults()\n+    {\n+        // Arrange\n+        var handler = new BooleanAutoCompleteHandler();\n+        var context = CreateContext<TestCommandWithBool>(\"Enabled\", queryString: \"t\");\n+\n+        // Act\n+        var options = await handler.GetOptionsAsync(context);\n+\n+        // Assert - should only return \"true\" when query is \"t\"\n+        options.Should().HaveCount(1);\n+        options.First().Value.Should().Be(\"true\");\n+    }\n+\n     #endregion\n \n     #region Test Helpers\ndiff --git a/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs b/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs\nindex 2070f12..cd464ec 100644\n--- a/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs\n+++ b/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs\n@@ -1,4 +1,5 @@\n ∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n using BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands;\n using Microsoft.Extensions.DependencyInjection;\n using Microsoft.VisualStudio.TestTools.UnitTesting;\n@@ -7,6 +8,11 @@ using FluentAssertions;\n using BitPantry.VirtualConsole.Testing;\n using BitPantry.CommandLine.Input;\n using BitPantry.CommandLine.Client;\n+using BitPantry.CommandLine.API;\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using System.Linq;\n \n namespace BitPantry.CommandLine.Tests\n {\n@@ -20,6 +26,7 @@ namespace BitPantry.CommandLine.Tests\n \n         private static ICommandRegistry _registry;\n         private static ServiceProvider _serviceProvider;\n+        private static IAutoCompleteHandlerRegistry _handlerRegistry;\n \n         private static VirtualConsoleAnsiAdapter _console;\n         private static ConsoleLineMirror _input;\n@@ -40,6 +47,9 @@ namespace BitPantry.CommandLine.Tests\n \n             _registry = builder.Build(services);\n \n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            _handlerRegistry = handlerBuilder.Build(services);\n+\n             _serviceProvider = services.BuildServiceProvider();\n         }\n \n@@ -48,7 +58,7 @@ namespace BitPantry.CommandLine.Tests\n         {\n             _console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n             _input = new ConsoleLineMirror(_console);\n-            _acCtrl = new AutoCompleteController(new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider));\n+            _acCtrl = new AutoCompleteController(new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry));\n         }\n \n         [TestMethod]\n@@ -71,11 +81,13 @@ namespace BitPantry.CommandLine.Tests\n             builder.RegisterCommand<Command>(); // Command\n             builder.RegisterCommand<CommandWithTwoArgs>(); // CommandWithTwoArgs\n             var registry = builder.Build(services);\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerBuilder.Build(services);\n             var sp = services.BuildServiceProvider();\n             \n             var console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n             var input = new ConsoleLineMirror(console);\n-            var acCtrl = new AutoCompleteController(new AutoCompleteOptionSetBuilder(registry, new NoopServerProxy(), sp));\n+            var acCtrl = new AutoCompleteController(new AutoCompleteOptionSetBuilder(registry, new NoopServerProxy(), sp, handlerRegistry));\n \n             input.Write(\"com\");\n \n@@ -241,5 +253,354 @@ namespace BitPantry.CommandLine.Tests\n             _input.Buffer.Should().Be(\"commandWithTwoArgs --a\");\n             _input.BufferPosition.Should().Be(22);\n         }\n+\n+        #region Spec 008-autocomplete-extensions\n+\n+        /// <summary>\n+        /// Implements: 008:TC-4.1\n+        /// End-to-end enum autocomplete works with default application.\n+        /// When user types \"err\" for an enum argument, autocomplete returns \"Error\".\n+        /// </summary>\n+        [TestMethod]\n+        public async Task EnumArgument_WithPrefix_AutocompletesMatchingValue()\n+        {\n+            // Arrange - set up a fresh registry with enum command\n+            var services = new ServiceCollection();\n+            var builder = new CommandRegistryBuilder();\n+            builder.RegisterCommand<CommandWithEnumArg>(); // CommandWithEnumArg --Level\n+            var registry = builder.Build(services);\n+\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerBuilder.Build(services);\n+\n+            var sp = services.BuildServiceProvider();\n+\n+            var console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n+            var input = new ConsoleLineMirror(console);\n+            var acCtrl = new AutoCompleteController(\n+                new AutoCompleteOptionSetBuilder(registry, new NoopServerProxy(), sp, handlerRegistry));\n+\n+            // User types command with partial enum value\n+            input.Write(\"CommandWithEnumArg --Level err\");\n+\n+            // Act - trigger autocomplete\n+            await acCtrl.Begin(input);\n+\n+            // Assert - enum value \"Error\" should be autocompleted\n+            // Buffer: \"CommandWithEnumArg --Level Error\" = 32 characters\n+            input.Buffer.Should().Be(\"CommandWithEnumArg --Level Error\");\n+            input.BufferPosition.Should().Be(32);\n+        }\n+\n+        /// <summary>\n+        /// Implements: 008:TC-4.2\n+        /// Custom Type Handler overrides built-in when registered after.\n+        /// The last-registered handler wins for matching types.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task CustomTypeHandler_RegisteredAfterBuiltIn_OverridesBuiltIn()\n+        {\n+            // Arrange - set up registry with enum command\n+            var services = new ServiceCollection();\n+            var cmdBuilder = new CommandRegistryBuilder();\n+            cmdBuilder.RegisterCommand<CommandWithEnumArg>(); // CommandWithEnumArg --Level\n+            var cmdRegistry = cmdBuilder.Build(services);\n+\n+            // Register custom handler AFTER built-ins (it should override EnumAutoCompleteHandler)\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            handlerBuilder.Register<CustomLogLevelHandler>(); // This returns \"CUSTOM_VALUE\" instead of enum values\n+            var handlerRegistry = handlerBuilder.Build(services);\n+\n+            var sp = services.BuildServiceProvider();\n+\n+            var console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n+            var input = new ConsoleLineMirror(console);\n+            var acCtrl = new AutoCompleteController(\n+                new AutoCompleteOptionSetBuilder(cmdRegistry, new NoopServerProxy(), sp, handlerRegistry));\n+\n+            // User types command with partial value\n+            input.Write(\"CommandWithEnumArg --Level \");\n+\n+            // Act - trigger autocomplete\n+            await acCtrl.Begin(input);\n+\n+            // Assert - custom handler's value should be used, NOT the built-in enum values\n+            input.Buffer.Should().Be(\"CommandWithEnumArg --Level CUSTOM_VALUE\");\n+        }\n+\n+        /// <summary>\n+        /// Implements: 008:TC-4.3\n+        /// Attribute Handler used even when matching Type Handler exists.\n+        /// Attribute takes precedence over type-matched handlers.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task AttributeHandler_TakesPrecedenceOverTypeHandler()\n+        {\n+            // Arrange - set up registry with command that has [AutoComplete<...>] attribute\n+            var services = new ServiceCollection();\n+            var cmdBuilder = new CommandRegistryBuilder();\n+            cmdBuilder.RegisterCommand<CommandWithAttributeHandler>(); // Has [AutoComplete<AttributeSpecifiedHandler>]\n+            var cmdRegistry = cmdBuilder.Build(services);\n+\n+            // Default handler registry includes EnumAutoCompleteHandler (which would match TestLogLevel)\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerBuilder.Build(services);\n+\n+            // Register the attribute-specified handler with DI\n+            services.AddTransient<AttributeSpecifiedHandler>();\n+\n+            var sp = services.BuildServiceProvider();\n+\n+            var console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n+            var input = new ConsoleLineMirror(console);\n+            var acCtrl = new AutoCompleteController(\n+                new AutoCompleteOptionSetBuilder(cmdRegistry, new NoopServerProxy(), sp, handlerRegistry));\n+\n+            // User types command\n+            input.Write(\"CommandWithAttributeHandler --Level \");\n+\n+            // Act - trigger autocomplete\n+            await acCtrl.Begin(input);\n+\n+            // Assert - attribute handler's value should be used, NOT the built-in enum values\n+            input.Buffer.Should().Be(\"CommandWithAttributeHandler --Level ATTRIBUTE_VALUE\");\n+        }\n+\n+        /// <summary>\n+        /// Implements: 008:TC-4.4\n+        /// Handler receives ProvidedValues in context with already-entered values.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task Handler_ReceivesProvidedValuesInContext()\n+        {\n+            // Arrange - set up registry with multi-argument command\n+            var services = new ServiceCollection();\n+            var cmdBuilder = new CommandRegistryBuilder();\n+            cmdBuilder.RegisterCommand<CommandWithMultipleArgs>(); // Has --First and --Second\n+            var cmdRegistry = cmdBuilder.Build(services);\n+\n+            // Register handler that captures context\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerBuilder.Build(services);\n+\n+            // Create and register the capturing handler\n+            var capturingHandler = new ContextCapturingHandler();\n+            services.AddSingleton<ContextCapturingHandler>(capturingHandler);\n+\n+            var sp = services.BuildServiceProvider();\n+\n+            var console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n+            var input = new ConsoleLineMirror(console);\n+            var acCtrl = new AutoCompleteController(\n+                new AutoCompleteOptionSetBuilder(cmdRegistry, new NoopServerProxy(), sp, handlerRegistry));\n+\n+            // User types command with --First already entered, now completing --Second\n+            input.Write(\"CommandWithMultipleArgs --First existingValue --Second \");\n+\n+            // Act - trigger autocomplete\n+            await acCtrl.Begin(input);\n+\n+            // Assert - handler should have received the First argument value in ProvidedValues\n+            capturingHandler.LastContext.Should().NotBeNull();\n+            capturingHandler.LastContext!.ProvidedValues.Should().NotBeEmpty();\n+            \n+            // Find the First argument and verify its value was captured\n+            var firstArg = capturingHandler.LastContext.ProvidedValues\n+                .FirstOrDefault(kv => kv.Key.Name == \"First\");\n+            firstArg.Key.Should().NotBeNull(\"ProvidedValues should contain the 'First' argument\");\n+            firstArg.Value.Should().Be(\"existingValue\");\n+        }\n+\n+        /// <summary>\n+        /// Implements: 008:TC-4.5\n+        /// Boolean autocomplete works end-to-end.\n+        /// When user types \"f\" for a bool argument, autocomplete returns \"false\".\n+        /// </summary>\n+        [TestMethod]\n+        public async Task BooleanArgument_WithPrefix_AutocompletesMatchingValue()\n+        {\n+            // Arrange - set up a fresh registry with bool command\n+            var services = new ServiceCollection();\n+            var builder = new CommandRegistryBuilder();\n+            builder.RegisterCommand<CommandWithBoolArg>(); // CommandWithBoolArg --Verbose\n+            var registry = builder.Build(services);\n+\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerBuilder.Build(services);\n+\n+            var sp = services.BuildServiceProvider();\n+\n+            var console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n+            var input = new ConsoleLineMirror(console);\n+            var acCtrl = new AutoCompleteController(\n+                new AutoCompleteOptionSetBuilder(registry, new NoopServerProxy(), sp, handlerRegistry));\n+\n+            // User types command with partial bool value\n+            input.Write(\"CommandWithBoolArg --Verbose f\");\n+\n+            // Act - trigger autocomplete\n+            await acCtrl.Begin(input);\n+\n+            // Assert - bool value \"false\" should be autocompleted\n+            input.Buffer.Should().Be(\"CommandWithBoolArg --Verbose false\");\n+        }\n+\n+        /// <summary>\n+        /// Implements: 008:TC-4.6\n+        /// Nullable enum autocomplete works end-to-end.\n+        /// When user types a prefix for a nullable enum argument, autocomplete returns matching enum values.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task NullableEnumArgument_WithPrefix_AutocompletesMatchingValue()\n+        {\n+            // Arrange - set up a fresh registry with nullable enum command\n+            var services = new ServiceCollection();\n+            var builder = new CommandRegistryBuilder();\n+            builder.RegisterCommand<CommandWithNullableEnumArg>(); // CommandWithNullableEnumArg --Level\n+            var registry = builder.Build(services);\n+\n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerBuilder.Build(services);\n+\n+            var sp = services.BuildServiceProvider();\n+\n+            var console = new VirtualConsoleAnsiAdapter(new BitPantry.VirtualConsole.VirtualConsole(80, 24));\n+            var input = new ConsoleLineMirror(console);\n+            var acCtrl = new AutoCompleteController(\n+                new AutoCompleteOptionSetBuilder(registry, new NoopServerProxy(), sp, handlerRegistry));\n+\n+            // User types command with partial enum value (nullable TestLogLevel?)\n+            input.Write(\"CommandWithNullableEnumArg --Level err\");\n+\n+            // Act - trigger autocomplete\n+            await acCtrl.Begin(input);\n+\n+            // Assert - enum value \"Error\" should be autocompleted (unwrapped from nullable)\n+            input.Buffer.Should().Be(\"CommandWithNullableEnumArg --Level Error\");\n+        }\n+\n+        #endregion\n+\n+        #region Test Helpers\n+\n+        /// <summary>\n+        /// Custom handler for TestLogLevel that returns a distinctive value\n+        /// to verify it overrides the built-in EnumAutoCompleteHandler.\n+        /// </summary>\n+        private class CustomLogLevelHandler : ITypeAutoCompleteHandler\n+        {\n+            public bool CanHandle(Type argumentType)\n+            {\n+                // Handle TestLogLevel (same type as built-in EnumAutoCompleteHandler would match)\n+                return argumentType == typeof(TestLogLevel);\n+            }\n+\n+            public Task<List<AutoCompleteOption>> GetOptionsAsync(\n+                AutoCompleteContext context,\n+                CancellationToken cancellationToken = default)\n+            {\n+                // Return a distinctive value to prove this handler was used\n+                var options = new List<AutoCompleteOption>\n+                {\n+                    new AutoCompleteOption(\"CUSTOM_VALUE\")\n+                };\n+                return Task.FromResult(options);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Handler specified via [AutoComplete<AttributeSpecifiedHandler>] attribute.\n+        /// Returns a distinctive value to prove attribute precedence.\n+        /// </summary>\n+        private class AttributeSpecifiedHandler : IAutoCompleteHandler\n+        {\n+            public Task<List<AutoCompleteOption>> GetOptionsAsync(\n+                AutoCompleteContext context,\n+                CancellationToken cancellationToken = default)\n+            {\n+                var options = new List<AutoCompleteOption>\n+                {\n+                    new AutoCompleteOption(\"ATTRIBUTE_VALUE\")\n+                };\n+                return Task.FromResult(options);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Command with [AutoComplete<>] attribute on enum argument.\n+        /// Even though TestLogLevel is an enum (matched by EnumAutoCompleteHandler),\n+        /// the attribute handler should take precedence.\n+        /// </summary>\n+        [Command]\n+        private class CommandWithAttributeHandler : CommandBase\n+        {\n+            [Argument]\n+            [AutoComplete<AttributeSpecifiedHandler>]\n+            public TestLogLevel Level { get; set; }\n+\n+            public void Execute(CommandExecutionContext ctx) { }\n+        }\n+\n+        /// <summary>\n+        /// Command with multiple string arguments for testing ProvidedValues context.\n+        /// </summary>\n+        [Command]\n+        private class CommandWithMultipleArgs : CommandBase\n+        {\n+            [Argument]\n+            public string First { get; set; }\n+\n+            [Argument]\n+            [AutoComplete<ContextCapturingHandler>]\n+            public string Second { get; set; }\n+\n+            public void Execute(CommandExecutionContext ctx) { }\n+        }\n+\n+        /// <summary>\n+        /// Handler that captures the context for verification.\n+        /// </summary>\n+        private class ContextCapturingHandler : IAutoCompleteHandler\n+        {\n+            public AutoCompleteContext? LastContext { get; private set; }\n+\n+            public Task<List<AutoCompleteOption>> GetOptionsAsync(\n+                AutoCompleteContext context,\n+                CancellationToken cancellationToken = default)\n+            {\n+                LastContext = context;\n+                var options = new List<AutoCompleteOption>\n+                {\n+                    new AutoCompleteOption(\"CAPTURED\")\n+                };\n+                return Task.FromResult(options);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Command with a boolean argument for testing BooleanAutoCompleteHandler.\n+        /// </summary>\n+        [Command]\n+        private class CommandWithBoolArg : CommandBase\n+        {\n+            [Argument]\n+            public bool Verbose { get; set; }\n+\n+            public void Execute(CommandExecutionContext ctx) { }\n+        }\n+\n+        /// <summary>\n+        /// Command with a nullable enum argument for testing nullable enum unwrapping.\n+        /// </summary>\n+        [Command]\n+        private class CommandWithNullableEnumArg : CommandBase\n+        {\n+            [Argument]\n+            public TestLogLevel? Level { get; set; }\n+\n+            public void Execute(CommandExecutionContext ctx) { }\n+        }\n+\n+        #endregion\n     }\n }\ndiff --git a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Alias.cs b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Alias.cs\nindex f4e829e..c516f50 100644\n--- a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Alias.cs\n+++ b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Alias.cs\n@@ -1,4 +1,5 @@\n-∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Processing.Parsing;\n using BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands;\n@@ -14,6 +15,7 @@ namespace BitPantry.CommandLine.Tests\n     {\n         private static ICommandRegistry _registry;\n         private static ServiceProvider _serviceProvider;\n+        private static IAutoCompleteHandlerRegistry _handlerRegistry;\n \n         [ClassInitialize]\n         public static void Initialize(TestContext ctx)\n@@ -27,13 +29,16 @@ namespace BitPantry.CommandLine.Tests\n \n             _registry = builder.Build(services);\n \n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            _handlerRegistry = handlerBuilder.Build(services);\n+\n             _serviceProvider = services.BuildServiceProvider();\n         }\n \n         [TestMethod]\n         public async Task AutoCompleteOneNoQuery_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithArg -\").GetElementAtCursorPosition(17));\n \n             opt.Should().NotBeNull();\n@@ -45,7 +50,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteOneArgUpperCaseQuery_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithArg -A\").GetElementAtCursorPosition(17));\n \n             opt.Should().NotBeNull();\n@@ -57,7 +62,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteOneArgBadQuery_NoResult()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithArg -c\").GetElementAtCursorPosition(17));\n \n             opt.Should().BeNull();\n@@ -66,7 +71,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteFirstAlias_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgs -\").GetElementAtCursorPosition(21));\n \n             opt.Should().NotBeNull();\n@@ -78,7 +83,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteFirstAliasSecondHasValue_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgs - -x\").GetElementAtCursorPosition(21));\n \n             opt.Should().NotBeNull();\n@@ -90,7 +95,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteFirstAliasSecondHasBadValue_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgs - -y\").GetElementAtCursorPosition(21));\n \n             opt.Should().NotBeNull();\ndiff --git a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_ArgName.cs b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_ArgName.cs\nindex 4bc6203..670bb6a 100644\n--- a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_ArgName.cs\n+++ b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_ArgName.cs\n@@ -1,4 +1,5 @@\n-∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Processing.Parsing;\n using BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands;\n@@ -14,6 +15,7 @@ namespace BitPantry.CommandLine.Tests\n     {\n         private static ICommandRegistry _registry;\n         private static ServiceProvider _serviceProvider;\n+        private static IAutoCompleteHandlerRegistry _handlerRegistry;\n \n         [ClassInitialize]\n         public static void Initialize(TestContext ctx)\n@@ -24,12 +26,14 @@ namespace BitPantry.CommandLine.Tests\n \n             builder.RegisterCommand<Command>(); // Command\n             builder.RegisterCommand<MultipleArgumentsAndAliases>(); // MultipleArgumentsAndAliases propertyTwo|p prop|X\n-            builder.RegisterCommand<CommandWithArgAc>(); // CommandWithArgAc arg1\n             builder.RegisterCommand<CommandWithArg>(); // CommandWithArgNoAc arg1\n             builder.RegisterCommand<CommandWithTwoArgs>(); // CommandWithTwoArgs arg1 xyzq\n \n             _registry = builder.Build(services);\n \n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            _handlerRegistry = handlerBuilder.Build(services);\n+\n             _serviceProvider = services.BuildServiceProvider();\n         }\n \n@@ -38,7 +42,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteNoArgs_NoResult()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"Command --\").GetElementAtCursorPosition(11));\n \n             opt.Should().BeNull();\n@@ -47,7 +51,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteOneArgNonMatchingQuery_NoResult()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithArg --m\").GetElementAtCursorPosition(19));\n \n             opt.Should().BeNull();\n@@ -56,7 +60,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteOneArgNoQuery_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithArg --\").GetElementAtCursorPosition(18));\n \n             opt.Should().NotBeNull();\n@@ -72,7 +76,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(18)]\n         public async Task AutoCompleteOneArgNoQueryDifferentPos_AutoCompleted(int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithArg --\").GetElementAtCursorPosition(position));\n \n             opt.Should().NotBeNull();\n@@ -85,22 +89,22 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteCmdNameOneArgNoQuery_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWith --\").GetElementAtCursorPosition(2));\n \n             opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n+            opt.Options.Should().HaveCount(2);\n \n             opt.Options[0].Value.Should().Be(\"CommandWithArg\");\n             opt.Options[0].GetFormattedValue().Should().Be(\"CommandWithArg\");\n \n-            opt.Options.Should().HaveCount(3);\n+            opt.Options.Should().HaveCount(2);\n         }\n \n         [TestMethod]\n         public async Task AutoCompleteArgNameNoCommand_NoResult()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\" --\").GetElementAtCursorPosition(2));\n \n             opt.Should().BeNull();\n@@ -109,7 +113,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteFirstArgument_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgs --\").GetElementAtCursorPosition(22));\n \n             opt.Should().NotBeNull();\n@@ -122,7 +126,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteSecondArgumentFirstHasValue_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgs --arg1 --\").GetElementAtCursorPosition(29));\n \n             opt.Should().NotBeNull();\n@@ -135,7 +139,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteSecondArgumentFirstHasBadValue_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgs --arg9 --\").GetElementAtCursorPosition(29));\n \n             opt.Should().NotBeNull();\n@@ -148,7 +152,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteFirstArgumentFirstHasNoValue_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgs --arg --\").GetElementAtCursorPosition(25));\n \n \ndiff --git a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_CommandName.cs b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_CommandName.cs\nindex a015e18..152b1aa 100644\n--- a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_CommandName.cs\n+++ b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_CommandName.cs\n@@ -1,4 +1,5 @@\n-∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Processing.Parsing;\n using BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands;\n@@ -18,6 +19,7 @@ namespace BitPantry.CommandLine.Tests\n     {\n         private static ICommandRegistry _registry;\n         private static ServiceProvider _serviceProvider;\n+        private static IAutoCompleteHandlerRegistry _handlerRegistry;\n \n         [ClassInitialize]\n         public static void Initialize(TestContext ctx)\n@@ -34,6 +36,9 @@ namespace BitPantry.CommandLine.Tests\n \n             _registry = builder.Build(services);\n \n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            _handlerRegistry = handlerBuilder.Build(services);\n+\n             _serviceProvider = services.BuildServiceProvider();\n         }\n \n@@ -48,7 +53,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\"COMM\", 3)] // all caps (case insensitive)\n         public async Task AutoCompleteCommandName_AutoCompleted(string query, int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(query).GetElementAtCursorPosition(position));\n \n             opt.Should().NotBeNull();\n@@ -64,7 +69,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\"myCommand\", 5)]\n         public async Task AutoCompleteCommandWithCustomName_AutoCompleted(string query, int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(query).GetElementAtCursorPosition(position));\n \n             opt.Should().NotBeNull();\n@@ -81,7 +86,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(-2)]\n         public void AutoCompleteOffPosition_NoResult(int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var elem = new ParsedInput(\"co\").GetElementAtCursorPosition(position);\n \n             elem.Should().BeNull();\n@@ -96,7 +101,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\" \")]\n         public void AutoCompleteEmptyString_NoResult(string emptyString)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var elem = new ParsedInput(emptyString).GetElementAtCursorPosition(1);\n             elem.Should().BeNull();\n         }\n@@ -108,7 +113,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompletePipedInput_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"command | my\").GetElementAtCursorPosition(13));\n \n             opt.Should().NotBeNull();\n@@ -119,7 +124,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteFirstCommandPipedInput_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"com | my\").GetElementAtCursorPosition(2));\n \n             opt.Should().NotBeNull();\ndiff --git a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Groups.cs b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Groups.cs\nindex 7b948cf..a8c87b5 100644\n--- a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Groups.cs\n+++ b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Groups.cs\n@@ -1,4 +1,5 @@\n using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Processing.Parsing;\n using BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands;\n@@ -19,6 +20,7 @@ namespace BitPantry.CommandLine.Tests\n     {\n         private static ICommandRegistry _registry;\n         private static ServiceProvider _serviceProvider;\n+        private static IAutoCompleteHandlerRegistry _handlerRegistry;\n \n         [ClassInitialize]\n         public static void Initialize(TestContext ctx)\n@@ -42,6 +44,9 @@ namespace BitPantry.CommandLine.Tests\n \n             _registry = builder.Build(services);\n \n+            var handlerBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            _handlerRegistry = handlerBuilder.Build(services);\n+\n             _serviceProvider = services.BuildServiceProvider();\n         }\n \n@@ -54,7 +59,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\"BITPANTRY\", 5)] // case insensitive\n         public async Task AutoCompleteGroupName_GroupReturned(string query, int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(query).GetElementAtCursorPosition(position));\n \n             opt.Should().NotBeNull();\n@@ -67,7 +72,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\"PARENT\", 3)] // case insensitive\n         public async Task AutoCompleteParentGroupName_GroupReturned(string query, int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(query).GetElementAtCursorPosition(position));\n \n             opt.Should().NotBeNull();\n@@ -77,7 +82,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteAtRoot_ShowsRootCommandsAndGroups()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // Typing \"c\" at root should show \"Command\" (root command) but not commands in groups\n             var opt = await ac.BuildOptions(new ParsedInput(\"c\").GetElementAtCursorPosition(1));\n \n@@ -97,7 +102,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\"BITPANTRY COMM\", 14)] // case insensitive\n         public async Task AutoCompleteCommandInGroup_CommandsReturned(string query, int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(query).GetElementAtCursorPosition(position));\n \n             opt.Should().NotBeNull();\n@@ -109,7 +114,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteInGroup_ShowsAllGroupCommands()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // Typing partial command in bitpantry group\n             var opt = await ac.BuildOptions(new ParsedInput(\"bitpantry Com\").GetElementAtCursorPosition(13));\n \n@@ -123,7 +128,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteExactCommandInGroup_ReturnsMatch()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"bitpantry CommandWithGroup\").GetElementAtCursorPosition(26));\n \n             opt.Should().NotBeNull();\n@@ -138,7 +143,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteChildGroupInParent_ShowsChildGroup()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // Typing \"chi\" after \"parent \" should show \"child\" group\n             var opt = await ac.BuildOptions(new ParsedInput(\"parent chi\").GetElementAtCursorPosition(10));\n \n@@ -149,7 +154,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteInParentGroup_ShowsCommandsAndChildGroups()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // In parent group, should see both parentcmd and child group\n             var opt = await ac.BuildOptions(new ParsedInput(\"parent p\").GetElementAtCursorPosition(9));\n \n@@ -160,7 +165,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteCommandInChildGroup_ReturnsChildCommands()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // Navigate to child group and autocomplete command\n             var opt = await ac.BuildOptions(new ParsedInput(\"parent child c\").GetElementAtCursorPosition(15));\n \n@@ -171,7 +176,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteInChildGroup_ShowsAllChildCommands()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // Both childcmd and anothercmd should be available\n             var opt = await ac.BuildOptions(new ParsedInput(\"parent child a\").GetElementAtCursorPosition(15));\n \n@@ -184,7 +189,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\"parent child anothercmd\", 24)]\n         public async Task AutoCompleteExactCommandInNestedGroup_ReturnsMatch(string query, int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(query).GetElementAtCursorPosition(position));\n \n             opt.Should().NotBeNull();\n@@ -201,7 +206,7 @@ namespace BitPantry.CommandLine.Tests\n         [DataRow(\"zzz\", 3)]\n         public async Task AutoCompleteNonExistent_NoResult(string query, int position)\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(query).GetElementAtCursorPosition(position));\n \n             // Should return empty options when no match\n@@ -214,7 +219,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteNonExistentCommandInGroup_NoResult()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"bitpantry xyz\").GetElementAtCursorPosition(13));\n \n             // Should return empty options when command doesn't exist in group\n@@ -227,7 +232,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteInvalidGroupPath_NoResult()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"nonexistentgroup cmd\").GetElementAtCursorPosition(20));\n \n             // Should return null or empty when group doesn't exist\n@@ -244,7 +249,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompletePipedInputWithGroup_AutoCompleted()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // After a pipe, should be able to autocomplete group path\n             var opt = await ac.BuildOptions(new ParsedInput(\"command | bitpantry Com\").GetElementAtCursorPosition(24));\n \n@@ -255,7 +260,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteGroupAfterPipe_GroupReturned()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"command | bit\").GetElementAtCursorPosition(14));\n \n             opt.Should().NotBeNull();\n@@ -269,7 +274,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteGroupWithTrailingSpace_ShowsGroupContents()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             // After typing group name and space, cursor is on next element\n             // This tests that we navigate into the group properly\n             var input = new ParsedInput(\"bitpantry C\");\n@@ -284,7 +289,7 @@ namespace BitPantry.CommandLine.Tests\n         [TestMethod]\n         public async Task AutoCompleteCaseInsensitive_MatchesRegardlessOfCase()\n         {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n+            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider, _handlerRegistry);\n             var opt = await ac.BuildOptions(new ParsedInput(\"BITPANTRY commandwithgroup\").GetElementAtCursorPosition(26));\n \n             opt.Should().NotBeNull();\ndiff --git a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Positional.cs b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Positional.cs\ndeleted file mode 100644\nindex 81df1c7..0000000\n--- a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Positional.cs\n+++ /dev/null\n@@ -1,177 +0,0 @@\n-using BitPantry.CommandLine.AutoComplete;\n-using BitPantry.CommandLine.Client;\n-using BitPantry.CommandLine.Processing.Parsing;\n-using BitPantry.CommandLine.Tests.Commands.PositionalCommands;\n-using FluentAssertions;\n-using Microsoft.Extensions.DependencyInjection;\n-using Microsoft.VisualStudio.TestTools.UnitTesting;\n-using System.Linq;\n-using System.Threading.Tasks;\n-\n-namespace BitPantry.CommandLine.Tests\n-{\n-    /// <summary>\n-    /// AutoComplete tests for positional arguments\n-    /// </summary>\n-    [TestClass]\n-    public class AutoCompleteSetBuilderTests_Positional\n-    {\n-        private static ICommandRegistry _registry;\n-        private static ServiceProvider _serviceProvider;\n-\n-        [ClassInitialize]\n-        public static void Initialize(TestContext ctx)\n-        {\n-            var services = new ServiceCollection();\n-\n-            var builder = new CommandRegistryBuilder();\n-\n-            builder.RegisterCommand<PositionalWithAutoCompleteCommand>();\n-            builder.RegisterCommand<SinglePositionalCommand>(); // No autocomplete function\n-            builder.RegisterCommand<IsRestCommand>(); // For IsRest tests\n-\n-            _registry = builder.Build(services);\n-\n-            _serviceProvider = services.BuildServiceProvider();\n-        }\n-\n-        /// <summary>\n-        /// AC-001: First positional slot - cursor after command name invokes pos0 autocomplete\n-        /// Note: When cursor is at end with trailing space, autocomplete shows command/arg names.\n-        /// User needs to start typing to get positional autocomplete.\n-        /// </summary>\n-        [TestMethod]\n-        public async Task AC001_FirstPositionalSlot_InvokesPos0AutoComplete()\n-        {\n-            // Arrange - \"positionalWithAutoCompleteCommand f\" with cursor at end (user started typing)\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var input = \"positionalWithAutoCompleteCommand f\";\n-            var parsedInput = new ParsedInput(input);\n-            var element = parsedInput.GetElementAtCursorPosition(input.Length);\n-            \n-            // Debug: Show all elements (accessing through ParsedCommands)\n-            System.Console.WriteLine($\"AC001 Input length: {input.Length}\");\n-            var parsedCmd = parsedInput.ParsedCommands.First();\n-            System.Console.WriteLine($\"AC001 Element count: {parsedCmd.Elements.Count}\");\n-            foreach (var el in parsedCmd.Elements)\n-            {\n-                System.Console.WriteLine($\"  {el.ElementType}: '{el.Value}' @ {el.StartPosition}-{el.EndPosition}\");\n-            }\n-            System.Console.WriteLine($\"AC001 Cursor element type: {element.ElementType}\");\n-            System.Console.WriteLine($\"AC001 Cursor element value: '{element.Value}'\");\n-\n-            // Act\n-            var opt = await ac.BuildOptions(element);\n-\n-            // Assert\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().Contain(o => o.Value == \"file1.txt\");\n-            opt.Options.Should().Contain(o => o.Value == \"file2.txt\");\n-        }\n-\n-        /// <summary>\n-        /// AC-002: Second positional slot - with first value typed and partial second value, invokes pos1 autocomplete\n-        /// Note: When cursor is at end with trailing space after a value, user needs to start typing\n-        /// to get next positional autocomplete.\n-        /// </summary>\n-        [TestMethod]\n-        public async Task AC002_SecondPositionalSlot_InvokesPos1AutoComplete()\n-        {\n-            // Arrange - \"positionalWithAutoCompleteCommand file1.txt r\" with partial second value\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var input = \"positionalWithAutoCompleteCommand file1.txt r\";\n-            var element = new ParsedInput(input).GetElementAtCursorPosition(input.Length);\n-\n-            // Act\n-            var opt = await ac.BuildOptions(element);\n-\n-            // Assert\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().Contain(o => o.Value == \"read\");\n-        }\n-\n-        /// <summary>\n-        /// AC-004: No autocomplete function - no suggestions returned\n-        /// </summary>\n-        [TestMethod]\n-        public async Task AC004_NoAutoCompleteFunction_NoSuggestions()\n-        {\n-            // Arrange - SinglePositionalCommand has no autocomplete function\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var input = \"singlePositionalCommand \";\n-            var element = new ParsedInput(input).GetElementAtCursorPosition(input.Length);\n-\n-            // Act\n-            var opt = await ac.BuildOptions(element);\n-\n-            // Assert - should be null or no options because there's no autocomplete function\n-            // (Note: might return group/command suggestions instead, so we check for positional arg suggestions)\n-            if (opt != null)\n-            {\n-                opt.Options.Should().NotContain(o => o.Value.Contains(\"positional\"));\n-            }\n-        }\n-\n-        /// <summary>\n-        /// AC-005: Context has prior values - when typing partial second positional,\n-        /// context should contain the first positional value\n-        /// </summary>\n-        [TestMethod]\n-        public async Task AC005_ContextHasPriorValues()\n-        {\n-            // Arrange - \"positionalWithAutoCompleteCommand file1.txt r\" with partial second value\n-            // The Mode autocomplete function adds \"has-context\" if prior values exist\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var input = \"positionalWithAutoCompleteCommand file1.txt r\";\n-            var element = new ParsedInput(input).GetElementAtCursorPosition(input.Length);\n-\n-            // Act\n-            var opt = await ac.BuildOptions(element);\n-\n-            // Assert - \"has-context\" should be in options if context was passed correctly\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().Contain(o => o.Value == \"has-context\");\n-        }\n-\n-        /// <summary>\n-        /// AC-006: After named option - named arg completion still works\n-        /// </summary>\n-        [TestMethod]\n-        public async Task AC006_AfterNamedOption_NamedArgCompletion()\n-        {\n-            // Arrange - \"positionalWithAutoCompleteCommand --\" cursor position after \"--\"\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var input = \"positionalWithAutoCompleteCommand --\";\n-            var element = new ParsedInput(input).GetElementAtCursorPosition(input.Length);\n-\n-            // Act\n-            var opt = await ac.BuildOptions(element);\n-\n-            // Assert - should suggest argument names (FileName, Mode, Verbose)\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCountGreaterOrEqualTo(1);\n-            // Check that at least one of the options is a valid argument\n-            opt.Options.Select(o => o.Value).Should().Contain(v => v.Contains(\"Verbose\", System.StringComparison.OrdinalIgnoreCase));\n-        }\n-\n-        /// <summary>\n-        /// AC-007: Partial positional - filter by partial value\n-        /// </summary>\n-        [TestMethod]\n-        public async Task AC007_PartialPositional_FilteredByPartialValue()\n-        {\n-            // Arrange - \"positionalWithAutoCompleteCommand fi\" with cursor at end\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var input = \"positionalWithAutoCompleteCommand fi\";\n-            var element = new ParsedInput(input).GetElementAtCursorPosition(input.Length);\n-\n-            // Act\n-            var opt = await ac.BuildOptions(element);\n-\n-            // Assert - should contain file1.txt and file2.txt (starting with \"fi\") but highlight current matching\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().Contain(o => o.Value == \"file1.txt\");\n-            opt.Options.Should().Contain(o => o.Value == \"file2.txt\");\n-        }\n-    }\n-}\ndiff --git a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Value.cs b/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Value.cs\ndeleted file mode 100644\nindex 0db79aa..0000000\n--- a/BitPantry.CommandLine.Tests/AutoCompleteSetBuilderTests_Value.cs\n+++ /dev/null\n@@ -1,195 +0,0 @@\n-∩╗┐using BitPantry.CommandLine.AutoComplete;\n-using BitPantry.CommandLine.Client;\n-using BitPantry.CommandLine.Processing.Parsing;\n-using BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands;\n-using FluentAssertions;\n-using Microsoft.Extensions.DependencyInjection;\n-using Microsoft.VisualStudio.TestTools.UnitTesting;\n-using System.Threading.Tasks;\n-\n-namespace BitPantry.CommandLine.Tests\n-{\n-    [TestClass]\n-    public class AutoCompleteSetBuilderTests_Value\n-    {\n-        private static ICommandRegistry _registry;\n-        private static ServiceProvider _serviceProvider;\n-\n-        [ClassInitialize]\n-        public static void Initialize(TestContext ctx)\n-        {\n-            var services = new ServiceCollection();\n-\n-            var builder = new CommandRegistryBuilder();\n-\n-            builder.RegisterCommand<CommandWithArgAc>(); // CommandWithArgAc arg1|a\n-            builder.RegisterCommand<CommandWithTwoArgAc>(); // CommandWithTwoArgAc arg1|a arg2|b\n-\n-            _registry = builder.Build(services);\n-\n-            _serviceProvider = services.BuildServiceProvider();\n-        }\n-\n-\n-\n-        [TestMethod]\n-        public async Task AutoCompleteArg1NoQuery_AutoCompleted()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = await ac.BuildOptions(new ParsedInput(\"CommandWithArgAc --arg1 \").GetElementAtCursorPosition(25));\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.Options[0].Value.Should().Be(\"Opt1\");\n-            opt.Options[0].GetFormattedValue().Should().Be(\"Opt1\");\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteArg1NoQueryAndSpace_AutoCompleted()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithArgAc --arg1   \").GetElementAtCursorPosition(27)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.Options[0].Value.Should().Be(\"Opt1\");\n-            opt.Options[0].GetFormattedValue().Should().Be(\"Opt1\");\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteBadArgName_NoResult()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithArgAc --arg \").GetElementAtCursorPosition(24)).Result;\n-\n-            opt.Should().BeNull();\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteArg1WithQuery_AutoCompleted()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithArgAc --arg1 b\").GetElementAtCursorPosition(26)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.CurrentOption.Value.Should().Be(\"Big2\");\n-            opt.CurrentOption.GetFormattedValue().Should().Be(\"Big2\");\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteArg1WithQueryMultipleOptions_AutoCompleted()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithArgAc --arg1 o\").GetElementAtCursorPosition(26)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.CurrentOption.Value.Should().Be(\"Opt1\");\n-            opt.CurrentOption.GetFormattedValue().Should().Be(\"Opt1\");\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteAliasNoQuery_AutoCompleted()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithArgAc -a \").GetElementAtCursorPosition(21)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.Options[0].Value.Should().Be(\"Opt1\");\n-            opt.Options[0].GetFormattedValue().Should().Be(\"Opt1\");\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteBadAlias_NoResult()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithArgAc -aaa \").GetElementAtCursorPosition(22)).Result;\n-\n-            opt.Should().BeNull();\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteFirstAliasNoQuery_AutoCompleted()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgAc -a  -b\").GetElementAtCursorPosition(24)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.Options[0].Value.Should().Be(\"Opt1\");\n-            opt.Options[0].GetFormattedValue().Should().Be(\"Opt1\");\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteCtxFirstArgWithSecondValue_AutoCompleted()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgAc -a  -b x\").GetElementAtCursorPosition(24)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.Options[0].Value.Should().Be(\"Opt1\");\n-            opt.Options[0].GetFormattedValue().Should().Be(\"Opt1\");\n-\n-            opt.Options[1].Value.Should().Be(\"Big2\");\n-            opt.Options[1].GetFormattedValue().Should().Be(\"Big2\");\n-\n-            opt.Options[2].Value.Should().Be(\"obc3\");\n-            opt.Options[2].GetFormattedValue().Should().Be(\"obc3\");\n-        }\n-\n-        [TestMethod]\n-        public void AutoCompleteCtxFirstArgWithAllValues_NoResult()\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgAc -a v -b x\").GetElementAtCursorPosition(25)).Result;\n-\n-            opt.Should().BeNull();\n-        }\n-\n-\n-        [DataTestMethod]\n-        [DataRow(24)]\n-        [DataRow(25)]\n-        [DataRow(26)]\n-        [DataRow(27)]\n-        public void AutoCompleteNoQuerySplitTrailingWhitespace_AutoCompleted(int cursorPosition)\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgAc -a     \").GetElementAtCursorPosition(cursorPosition)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.Options[0].Value.Should().Be(\"Opt1\");\n-            opt.Options[0].GetFormattedValue().Should().Be(\"Opt1\");\n-        }\n-\n-        [DataTestMethod]\n-        [DataRow(24)]\n-        [DataRow(25)]\n-        [DataRow(26)]\n-        [DataRow(27)]\n-        public void AutoCompleteFirstAliasNoQuerySplitWhitespace_AutoCompleted(int cursorPosition)\n-        {\n-            var ac = new AutoCompleteOptionSetBuilder(_registry, new NoopServerProxy(), _serviceProvider);\n-            var opt = ac.BuildOptions(new ParsedInput(\"CommandWithTwoArgAc -a     -b\").GetElementAtCursorPosition(cursorPosition)).Result;\n-\n-            opt.Should().NotBeNull();\n-            opt.Options.Should().HaveCount(3);\n-\n-            opt.Options[0].Value.Should().Be(\"Opt1\");\n-            opt.Options[0].GetFormattedValue().Should().Be(\"Opt1\");\n-        }\n-\n-    }\n-}\ndiff --git a/BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithArgAc.cs b/BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithArgAc.cs\ndeleted file mode 100644\nindex 5f5f8e4..0000000\n--- a/BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithArgAc.cs\n+++ /dev/null\n@@ -1,26 +0,0 @@\n-∩╗┐using BitPantry.CommandLine.API;\n-using BitPantry.CommandLine.AutoComplete;\n-using System.Collections.Generic;\n-\n-namespace BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands\n-{\n-    [Command]\n-    public class CommandWithArgAc : CommandBase\n-    {\n-        [Argument(AutoCompleteFunctionName = nameof(AutoComplete_Arg1))]\n-        [Alias('a')]\n-        public string Arg1 { get; set; }\n-\n-        public void Execute(CommandExecutionContext context) { }\n-\n-        public List<AutoCompleteOption> AutoComplete_Arg1(AutoCompleteContext context)\n-        {\n-            return new List<AutoCompleteOption>\n-            {\n-                new AutoCompleteOption(\"Opt1\"),\n-                new AutoCompleteOption(\"Big2\"),\n-                new AutoCompleteOption(\"obc3\"),\n-            };\n-        }\n-    }\n-}\ndiff --git a/BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithTwoArgAc.cs b/BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithTwoArgAc.cs\ndeleted file mode 100644\nindex cecadb1..0000000\n--- a/BitPantry.CommandLine.Tests/Commands/AutoCompleteCommands/CommandWithTwoArgAc.cs\n+++ /dev/null\n@@ -1,30 +0,0 @@\n-∩╗┐using BitPantry.CommandLine.API;\n-using BitPantry.CommandLine.AutoComplete;\n-using System.Collections.Generic;\n-\n-namespace BitPantry.CommandLine.Tests.Commands.AutoCompleteCommands\n-{\n-    [Command]\n-    public class CommandWithTwoArgAc : CommandBase\n-    {\n-        [Argument(AutoCompleteFunctionName = nameof(AutoComplete_Arg1))]\n-        [Alias('a')]\n-        public string Arg1 { get; set; }\n-\n-        [Argument(AutoCompleteFunctionName = nameof(AutoComplete_Arg1))]\n-        [Alias('b')]\n-        public string Arg2 { get; set; }\n-\n-        public void Execute(CommandExecutionContext context) { }\n-\n-        public List<AutoCompleteOption> AutoComplete_Arg1(AutoCompleteContext context)\n-        {\n-            return new List<AutoCompleteOption>\n-            {\n-                new AutoCompleteOption(\"Opt1\"),\n-                new AutoCompleteOption(\"Big2\"),\n-                new AutoCompleteOption(\"obc3\"),\n-            };\n-        }\n-    }\n-}\ndiff --git a/BitPantry.CommandLine.Tests/Commands/PositionalCommands/PositionalWithAutoCompleteCommand.cs b/BitPantry.CommandLine.Tests/Commands/PositionalCommands/PositionalWithAutoCompleteCommand.cs\ndeleted file mode 100644\nindex b9a7fae..0000000\n--- a/BitPantry.CommandLine.Tests/Commands/PositionalCommands/PositionalWithAutoCompleteCommand.cs\n+++ /dev/null\n@@ -1,57 +0,0 @@\n-using BitPantry.CommandLine.API;\n-using BitPantry.CommandLine.AutoComplete;\n-using System;\n-using System.Collections.Generic;\n-\n-namespace BitPantry.CommandLine.Tests.Commands.PositionalCommands\n-{\n-    /// <summary>\n-    /// Test command with positional argument that has auto-complete\n-    /// </summary>\n-    [Command]\n-    class PositionalWithAutoCompleteCommand : CommandBase\n-    {\n-        [Argument(Position = 0, AutoCompleteFunctionName = nameof(GetFileCompletions))]\n-        public string FileName { get; set; }\n-\n-        [Argument(Position = 1, AutoCompleteFunctionName = nameof(GetModeCompletions))]\n-        public string Mode { get; set; }\n-\n-        [Argument]\n-        [Alias('v')]\n-        public Option Verbose { get; set; }\n-\n-        public List<AutoCompleteOption> GetFileCompletions(AutoCompleteContext context)\n-        {\n-            return new List<AutoCompleteOption>\n-            {\n-                new AutoCompleteOption(\"file1.txt\"),\n-                new AutoCompleteOption(\"file2.txt\"),\n-                new AutoCompleteOption(\"data.csv\")\n-            };\n-        }\n-\n-        public List<AutoCompleteOption> GetModeCompletions(AutoCompleteContext context)\n-        {\n-            var options = new List<AutoCompleteOption>\n-            {\n-                new AutoCompleteOption(\"read\"),\n-                new AutoCompleteOption(\"write\"),\n-                new AutoCompleteOption(\"append\")\n-            };\n-            \n-            // If FileName was provided in context, add a marker option\n-            if (context.Values != null && context.Values.Count > 0)\n-            {\n-                options.Add(new AutoCompleteOption(\"has-context\"));\n-            }\n-            \n-            return options;\n-        }\n-\n-        public void Execute(CommandExecutionContext ctx)\n-        {\n-            throw new NotImplementedException();\n-        }\n-    }\n-}\ndiff --git a/BitPantry.CommandLine/API/ArgumentAttribute.cs b/BitPantry.CommandLine/API/ArgumentAttribute.cs\nindex e5be756..5444fdd 100644\n--- a/BitPantry.CommandLine/API/ArgumentAttribute.cs\n+++ b/BitPantry.CommandLine/API/ArgumentAttribute.cs\n@@ -7,11 +7,6 @@ namespace BitPantry.CommandLine.API\n     {\n         public string Name { get; set; }\n \n-        /// <summary>\n-        // The name of the function in the same class that can provide auto complete values - the function should accept an AutoCompleteContext and return a List<string>\n-        /// </summary>\n-        public string AutoCompleteFunctionName { get; set; }\n-\n         /// <summary>\n         /// Whether or not the argument is required\n         /// </summary>\ndiff --git a/BitPantry.CommandLine/AutoComplete/AutoCompleteContext.cs b/BitPantry.CommandLine/AutoComplete/AutoCompleteContext.cs\ndeleted file mode 100644\nindex d8a530b..0000000\n--- a/BitPantry.CommandLine/AutoComplete/AutoCompleteContext.cs\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-∩╗┐using BitPantry.CommandLine.Component;\n-using System.Collections.Generic;\n-\n-namespace BitPantry.CommandLine.AutoComplete\n-{\n-    public record AutoCompleteContext(string QueryString, Dictionary<ArgumentInfo, string> Values) { }\n-}\ndiff --git a/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSetBuilder.cs b/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSetBuilder.cs\nindex 61f58f9..d0f633e 100644\n--- a/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSetBuilder.cs\n+++ b/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSetBuilder.cs\n@@ -1,4 +1,5 @@\n-∩╗┐using BitPantry.CommandLine.Client;\n+∩╗┐using BitPantry.CommandLine.AutoComplete.Handlers;\n+using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Component;\n using BitPantry.CommandLine.Processing.Parsing;\n using Microsoft.Extensions.DependencyInjection;\n@@ -18,18 +19,27 @@ namespace BitPantry.CommandLine.AutoComplete\n         private readonly ICommandRegistry _registry;\n         private readonly IServerProxy _serverProxy;\n         private readonly IServiceProvider _serviceProvider;\n+        private readonly IAutoCompleteHandlerRegistry _handlerRegistry;\n+        private readonly AutoCompleteHandlerActivator _activator;\n \n         /// <summary>\n-        /// Initializes a new instance of hte AutoCompleteOptionsBuilder\n+        /// Initializes a new instance of the AutoCompleteOptionsBuilder\n         /// </summary>\n         /// <param name=\"registry\">The command registry to use for auto complete values of registered command elements</param>\n         /// <param name=\"serverProxy\">The server proxy to use for auto completion of argument values</param>\n-        /// <param name=\"serviceProvider\">The service provider to use for instantiating command objects to execute auto complete functions</param>\n-        public AutoCompleteOptionSetBuilder(ICommandRegistry registry, IServerProxy serverProxy, IServiceProvider serviceProvider)\n+        /// <param name=\"serviceProvider\">The service provider to use for instantiating command objects and handlers</param>\n+        /// <param name=\"handlerRegistry\">The handler registry for autocomplete handlers</param>\n+        public AutoCompleteOptionSetBuilder(\n+            ICommandRegistry registry, \n+            IServerProxy serverProxy, \n+            IServiceProvider serviceProvider,\n+            IAutoCompleteHandlerRegistry handlerRegistry)\n         {\n             _registry = registry;\n             _serverProxy = serverProxy;\n             _serviceProvider = serviceProvider;\n+            _handlerRegistry = handlerRegistry;\n+            _activator = new AutoCompleteHandlerActivator(serviceProvider);\n         }\n \n \n@@ -180,7 +190,7 @@ namespace BitPantry.CommandLine.AutoComplete\n         }\n \n         /// <summary>\n-        /// Builds options for a positional argument by invoking its autocomplete function\n+        /// Builds options for a positional argument using the handler registry\n         /// </summary>\n         private async Task<AutoCompleteOptionSet> BuildOptions_PositionalArgument(ParsedCommandElement parsedElement, CancellationToken token = default)\n         {\n@@ -197,13 +207,11 @@ namespace BitPantry.CommandLine.AutoComplete\n             if (positionalArgs.Count == 0) return null;\n \n             // Determine which positional argument this element corresponds to\n-            // Get all PositionalValue elements (not including Empty elements)\n             var allPositionalElements = parsedElement.ParentCommand.Elements\n                 .Where(e => e.ElementType == CommandElementType.PositionalValue)\n                 .ToList();\n \n             // Find elements that are part of command path vs actual positional values\n-            // The command path length = number of elements that form the command path\n             var commandPathLength = GetCommandPathLength(parsedElement.ParentCommand);\n             \n             // Get positional value elements after the command path\n@@ -213,8 +221,6 @@ namespace BitPantry.CommandLine.AutoComplete\n             int currentPositionalIndex;\n             if (parsedElement.ElementType == CommandElementType.Empty)\n             {\n-                // For Empty elements, the index is the count of existing positional values\n-                // (i.e., this would be the next positional argument slot)\n                 currentPositionalIndex = positionalValueElements.Count;\n             }\n             else\n@@ -239,63 +245,29 @@ namespace BitPantry.CommandLine.AutoComplete\n                 }\n             }\n \n-            if (argInfo == null || string.IsNullOrEmpty(argInfo.AutoCompleteFunctionName))\n-                return null;\n+            if (argInfo == null) return null;\n \n-            // Build the autocomplete context with prior positional values\n-            var autoCompleteCtx = BuildAutoCompleteContextWithPositionalValues(parsedElement, cmdInfo, positionalValueElements, currentPositionalIndex);\n+            // Find a handler for this argument\n+            var handlerType = _handlerRegistry?.FindHandler(argInfo, _activator);\n+            if (handlerType == null) return null;\n \n-            // Execute the autocomplete function\n-            List<AutoCompleteOption> results = new List<AutoCompleteOption>();\n+            // Build handler context with positional values\n+            var context = BuildHandlerContextWithPositionalValues(parsedElement, cmdInfo, argInfo, positionalValueElements, currentPositionalIndex);\n \n-            if (cmdInfo.IsRemote)\n-            {\n-                results = await _serverProxy.AutoComplete(cmdInfo.Group?.FullPath, cmdInfo.Name, argInfo.AutoCompleteFunctionName, argInfo.IsAutoCompleteFunctionAsync, autoCompleteCtx, token) ?? [];\n-            }\n-            else\n-            {\n-                using var scope = _serviceProvider.CreateScope();\n-                var cmd = scope.ServiceProvider.GetRequiredService(cmdInfo.Type);\n-                var method = cmdInfo.Type.GetMethod(argInfo.AutoCompleteFunctionName);\n-                var args = new[] { autoCompleteCtx };\n-\n-                results = await (argInfo.IsAutoCompleteFunctionAsync\n-                    ? (Task<List<AutoCompleteOption>>)method.Invoke(cmd, args)\n-                    : Task.Factory.StartNew(() => (List<AutoCompleteOption>)method.Invoke(cmd, args)));\n-            }\n+            // Activate and invoke the handler (scope disposed after use)\n+            using var activation = _activator.Activate(handlerType);\n+            var results = await activation.Handler.GetOptionsAsync(context, token);\n \n             return BuildAutoCompleteOptionSet(results, parsedElement.Value);\n         }\n \n         /// <summary>\n-        /// Gets the command path length (how many elements form the command path vs positional arguments)\n+        /// Builds handler context that includes prior positional argument values\n         /// </summary>\n-        private int GetCommandPathLength(ParsedCommand parsedCmd)\n-        {\n-            var pathElements = parsedCmd.Elements\n-                .Where(e => e.ElementType == CommandElementType.Command || e.ElementType == CommandElementType.PositionalValue)\n-                .ToList();\n-\n-            // Try progressively shorter paths from longest to shortest\n-            for (int length = pathElements.Count; length >= 1; length--)\n-            {\n-                var tryPath = string.Join(\" \", pathElements.Take(length).Select(e => e.Value));\n-                var cmd = _registry.Find(tryPath);\n-                if (cmd != null)\n-                {\n-                    return length;\n-                }\n-            }\n-\n-            return 1; // Default to 1 (just the command name)\n-        }\n-\n-        /// <summary>\n-        /// Builds an AutoCompleteContext that includes prior positional argument values\n-        /// </summary>\n-        private AutoCompleteContext BuildAutoCompleteContextWithPositionalValues(\n+        private Handlers.AutoCompleteContext BuildHandlerContextWithPositionalValues(\n             ParsedCommandElement parsedElement,\n             CommandInfo cmdInfo,\n+            ArgumentInfo argInfo,\n             List<ParsedCommandElement> positionalValueElements,\n             int currentPositionalIndex)\n         {\n@@ -316,17 +288,49 @@ namespace BitPantry.CommandLine.AutoComplete\n                 }\n             }\n \n-            // Also include named arguments from the standard context builder\n-            var standardCtx = BuildAutoCompleteContext(parsedElement);\n-            foreach (var kvp in standardCtx.Values)\n+            // Also include named argument values\n+            foreach (var val in parsedElement.ParentCommand.Elements.Where(e => e.ElementType == CommandElementType.ArgumentValue))\n+            {\n+                var matchingArg = val.IsPairedWith.ElementType == CommandElementType.ArgumentName\n+                    ? cmdInfo.Arguments.FirstOrDefault(a => a.Name.Equals(val.IsPairedWith.Value, StringComparison.InvariantCultureIgnoreCase))\n+                    : cmdInfo.Arguments.FirstOrDefault(a => a.Alias.ToString().Equals(val.IsPairedWith.Value, StringComparison.InvariantCultureIgnoreCase));\n+\n+                if (matchingArg != null && !values.ContainsKey(matchingArg))\n+                    values[matchingArg] = val.Raw;\n+            }\n+\n+            return new Handlers.AutoCompleteContext\n+            {\n+                QueryString = parsedElement.Value ?? string.Empty,\n+                FullInput = string.Join(\" \", parsedElement.ParentCommand.Elements.Select(e => e.Raw)),\n+                CursorPosition = parsedElement.ParentCommand.Elements.ToList().IndexOf(parsedElement),\n+                ArgumentInfo = argInfo,\n+                CommandInfo = cmdInfo,\n+                ProvidedValues = values\n+            };\n+        }\n+\n+        /// <summary>\n+        /// Gets the command path length (how many elements form the command path vs positional arguments)\n+        /// </summary>\n+        private int GetCommandPathLength(ParsedCommand parsedCmd)\n+        {\n+            var pathElements = parsedCmd.Elements\n+                .Where(e => e.ElementType == CommandElementType.Command || e.ElementType == CommandElementType.PositionalValue)\n+                .ToList();\n+\n+            // Try progressively shorter paths from longest to shortest\n+            for (int length = pathElements.Count; length >= 1; length--)\n             {\n-                if (!values.ContainsKey(kvp.Key))\n+                var tryPath = string.Join(\" \", pathElements.Take(length).Select(e => e.Value));\n+                var cmd = _registry.Find(tryPath);\n+                if (cmd != null)\n                 {\n-                    values[kvp.Key] = kvp.Value;\n+                    return length;\n                 }\n             }\n \n-            return new AutoCompleteContext(parsedElement.Value, values);\n+            return 1; // Default to 1 (just the command name)\n         }\n \n         /// <summary>\n@@ -524,63 +528,70 @@ namespace BitPantry.CommandLine.AutoComplete\n         }\n \n         /// <summary>\n-        /// Builds options for an argument value\n+        /// Builds options for an argument value using the handler registry\n         /// </summary>\n         private async Task<AutoCompleteOptionSet> BuildOptions_ArgumentValue(ParsedCommandElement parsedElement, CancellationToken token)\n         {\n-            // If the input parser labeled the parsed element as an argument value, then get the associated argument, but if the argument value is an empty string\n-            // the parser will have typed the element as Empty and any immediately preceeding argument element is needed\n-\n+            // If the input parser labeled the parsed element as an argument value, then get the associated argument\n             var argumentElement = parsedElement.IsPairedWith ?? GetArgumentElementForEmptyParsedElement(parsedElement);\n-            if (argumentElement == null) return null; // if no argument element, then this isn't an argument value so treat as unexpected\n-\n-            // get the command info - if null, unable to determine auto complete function - return\n+            if (argumentElement == null) return null;\n \n+            // get the command info\n             var cmdInfo = GetCommandInfo(parsedElement);\n             if (cmdInfo == null) return null;\n \n             // get the arg info that matches the parsed input argument name / alias\n-\n             var argInfo = argumentElement.ElementType == CommandElementType.ArgumentName\n-                ? cmdInfo.Arguments.Where(a => a.Name.Equals(argumentElement.Value, StringComparison.InvariantCultureIgnoreCase)).FirstOrDefault()\n-                : cmdInfo.Arguments.Where(a => a.Alias.ToString().Equals(argumentElement.Value, StringComparison.InvariantCultureIgnoreCase)).FirstOrDefault();\n-\n-            // if the argument could not be found, or the auto complete function is not defined, return\n-\n-            if (argInfo == null || string.IsNullOrEmpty(argInfo.AutoCompleteFunctionName)) return null;\n+                ? cmdInfo.Arguments.FirstOrDefault(a => a.Name.Equals(argumentElement.Value, StringComparison.InvariantCultureIgnoreCase))\n+                : cmdInfo.Arguments.FirstOrDefault(a => a.Alias.ToString().Equals(argumentElement.Value, StringComparison.InvariantCultureIgnoreCase));\n \n-            // otherwise execute\n+            if (argInfo == null) return null;\n \n-            var autoCompleteCtx = BuildAutoCompleteContext(parsedElement);\n+            // Find a handler for this argument\n+            var handlerType = _handlerRegistry?.FindHandler(argInfo, _activator);\n+            if (handlerType == null) return null;\n \n-            List<AutoCompleteOption> results = new List<AutoCompleteOption>();\n+            // Build handler context\n+            var context = BuildHandlerContext(parsedElement, cmdInfo, argInfo);\n \n-            if (cmdInfo.IsRemote) // remote server execution\n-            {\n-                // TODO: T075/T076 - Update IServerProxy to use groupPath instead of cmdNamespace\n-                results = \n-                    await _serverProxy.AutoComplete(cmdInfo.Group?.FullPath, cmdInfo.Name, argInfo.AutoCompleteFunctionName, argInfo.IsAutoCompleteFunctionAsync, autoCompleteCtx, token) \n-                    ?? [];\n-            }\n-            else // local command execution\n-            {\n-                // instantiate the command and execute the auto complete function\n+            // Activate and invoke the handler (scope disposed after use)\n+            using var activation = _activator.Activate(handlerType);\n+            var results = await activation.Handler.GetOptionsAsync(context, token);\n \n-                using var scope = _serviceProvider.CreateScope();\n-                var cmd = scope.ServiceProvider.GetRequiredService(cmdInfo.Type);\n+            // build options from the results\n+            return BuildOptionSet(results, parsedElement.Value, true);\n+        }\n \n-                var method = cmdInfo.Type.GetMethod(argInfo.AutoCompleteFunctionName);\n-                var args = new[] { autoCompleteCtx };\n+        /// <summary>\n+        /// Builds the new handler context for autocomplete handlers\n+        /// </summary>\n+        private Handlers.AutoCompleteContext BuildHandlerContext(\n+            ParsedCommandElement parsedElement, \n+            CommandInfo cmdInfo, \n+            ArgumentInfo argInfo)\n+        {\n+            // Build dictionary of all argument values defined in the parsed input\n+            var argValueDict = new Dictionary<ArgumentInfo, string>();\n \n-                results = await (argInfo.IsAutoCompleteFunctionAsync\n-                        ? (Task<List<AutoCompleteOption>>)method.Invoke(cmd, args)\n-                        : Task.Factory.StartNew(() => (List<AutoCompleteOption>)method.Invoke(cmd, args)));\n+            foreach (var val in parsedElement.ParentCommand.Elements.Where(e => e.ElementType == CommandElementType.ArgumentValue))\n+            {\n+                var matchingArg = val.IsPairedWith.ElementType == CommandElementType.ArgumentName\n+                    ? cmdInfo.Arguments.FirstOrDefault(a => a.Name.Equals(val.IsPairedWith.Value, StringComparison.InvariantCultureIgnoreCase))\n+                    : cmdInfo.Arguments.FirstOrDefault(a => a.Alias.ToString().Equals(val.IsPairedWith.Value, StringComparison.InvariantCultureIgnoreCase));\n \n+                if (matchingArg != null)\n+                    argValueDict[matchingArg] = val.Raw;\n             }\n \n-            // build options from the results\n-\n-            return BuildOptionSet(results, parsedElement.Value, true);\n+            return new Handlers.AutoCompleteContext\n+            {\n+                QueryString = parsedElement.Value ?? string.Empty,\n+                FullInput = string.Join(\" \", parsedElement.ParentCommand.Elements.Select(e => e.Raw)),\n+                CursorPosition = parsedElement.ParentCommand.Elements.ToList().IndexOf(parsedElement),\n+                ArgumentInfo = argInfo,\n+                CommandInfo = cmdInfo,\n+                ProvidedValues = argValueDict\n+            };\n         }\n \n         /// <summary>\n@@ -618,32 +629,6 @@ namespace BitPantry.CommandLine.AutoComplete\n             return null;\n         }\n \n-        /// <summary>\n-        /// Builds an auto complete context to be pased to a commands auto complete function\n-        /// </summary>\n-        /// <returns></returns>\n-        private AutoCompleteContext BuildAutoCompleteContext(ParsedCommandElement parsedElement)\n-        {\n-            // build dictionary of all argument values defined in the parsed input for valid arguments\n-\n-            var cmdInfo = GetCommandInfo(parsedElement);\n-            var argValueDict = new Dictionary<ArgumentInfo, string>();\n-\n-            foreach (var val in parsedElement.ParentCommand.Elements.Where(e => e.ElementType == CommandElementType.ArgumentValue))\n-            {\n-                var argInfo = val.IsPairedWith.ElementType == CommandElementType.ArgumentName\n-                    ? cmdInfo.Arguments.FirstOrDefault(a => a.Name.Equals(val.IsPairedWith.Value, StringComparison.InvariantCultureIgnoreCase))\n-                    : cmdInfo.Arguments.FirstOrDefault(a => a.Alias.ToString().Equals(val.IsPairedWith.Value, StringComparison.InvariantCultureIgnoreCase));\n-\n-                if (argInfo != null)\n-                    argValueDict.Add(argInfo, val.Raw);\n-            }\n-\n-            // return the context\n-\n-            return new AutoCompleteContext(parsedElement.Value, argValueDict);\n-        }\n-\n         /// <summary>\n         /// Gets the command info associated with the parsed element\n         /// </summary>\ndiff --git a/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistry.cs b/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistry.cs\nindex 270dade..794b698 100644\n--- a/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistry.cs\n+++ b/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistry.cs\n@@ -10,7 +10,7 @@ namespace BitPantry.CommandLine.AutoComplete.Handlers\n {\n     /// <summary>\n     /// Immutable registry for autocomplete handler lookup at runtime.\n-    /// Does NOT activate handlers - use HandlerActivator for that.\n+    /// Does NOT activate handlers - use AutoCompleteHandlerActivator for that.\n     /// </summary>\n     public class AutoCompleteHandlerRegistry : IAutoCompleteHandlerRegistry\n     {\n@@ -38,7 +38,7 @@ namespace BitPantry.CommandLine.AutoComplete.Handlers\n         /// <param name=\"argumentInfo\">The argument to find a handler for.</param>\n         /// <param name=\"activator\">The activator to use for checking CanHandle on type handlers.</param>\n         /// <returns>The handler type, or null if none matches.</returns>\n-        public Type? FindHandler(ArgumentInfo argumentInfo, HandlerActivator activator)\n+        public Type? FindHandler(ArgumentInfo argumentInfo, AutoCompleteHandlerActivator activator)\n         {\n             var propertyInfo = argumentInfo.PropertyInfo.GetPropertyInfo();\n \n@@ -61,9 +61,9 @@ namespace BitPantry.CommandLine.AutoComplete.Handlers\n             for (int i = _typeHandlers.Count - 1; i >= 0; i--)\n             {\n                 var handlerType = _typeHandlers[i];\n-                var handler = activator.Activate(handlerType);\n+                using var activation = activator.Activate(handlerType);\n                 \n-                if (handler is ITypeAutoCompleteHandler typeHandler && typeHandler.CanHandle(lookupType))\n+                if (activation.Handler is ITypeAutoCompleteHandler typeHandler && typeHandler.CanHandle(lookupType))\n                 {\n                     return handlerType;\n                 }\ndiff --git a/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistryBuilder.cs b/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistryBuilder.cs\nindex 23f079b..b938aff 100644\n--- a/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistryBuilder.cs\n+++ b/BitPantry.CommandLine/AutoComplete/Handlers/AutoCompleteHandlerRegistryBuilder.cs\n@@ -7,12 +7,25 @@ namespace BitPantry.CommandLine.AutoComplete.Handlers\n     /// <summary>\n     /// Mutable builder for registering autocomplete handlers.\n     /// Once Build() is called, returns an immutable IAutoCompleteHandlerRegistry.\n+    /// Built-in handlers (EnumAutoCompleteHandler, BooleanAutoCompleteHandler) are \n+    /// registered by default, following the same pattern as CommandRegistry.\n     /// </summary>\n     public class AutoCompleteHandlerRegistryBuilder : IAutoCompleteHandlerRegistryBuilder\n     {\n         private readonly List<Type> _typeHandlers = new List<Type>();\n         private bool _isBuilt = false;\n \n+        /// <summary>\n+        /// Creates a new handler registry builder with built-in handlers registered.\n+        /// Built-in handlers: EnumAutoCompleteHandler, BooleanAutoCompleteHandler.\n+        /// </summary>\n+        public AutoCompleteHandlerRegistryBuilder()\n+        {\n+            // Register built-in handlers by default (follows CommandRegistry pattern)\n+            _typeHandlers.Add(typeof(EnumAutoCompleteHandler));\n+            _typeHandlers.Add(typeof(BooleanAutoCompleteHandler));\n+        }\n+\n         /// <summary>\n         /// Registers a type handler.\n         /// </summary>\ndiff --git a/BitPantry.CommandLine/AutoComplete/Handlers/BooleanAutoCompleteHandler.cs b/BitPantry.CommandLine/AutoComplete/Handlers/BooleanAutoCompleteHandler.cs\nindex 763770b..bc12d58 100644\n--- a/BitPantry.CommandLine/AutoComplete/Handlers/BooleanAutoCompleteHandler.cs\n+++ b/BitPantry.CommandLine/AutoComplete/Handlers/BooleanAutoCompleteHandler.cs\n@@ -1,5 +1,6 @@\n using System;\n using System.Collections.Generic;\n+using System.Linq;\n using System.Threading;\n using System.Threading.Tasks;\n \n@@ -31,11 +32,13 @@ public class BooleanAutoCompleteHandler : ITypeAutoCompleteHandler\n         AutoCompleteContext context,\n         CancellationToken cancellationToken = default)\n     {\n-        var options = new List<AutoCompleteOption>\n-        {\n-            new AutoCompleteOption(\"false\"),\n-            new AutoCompleteOption(\"true\")\n-        };\n+        var values = new[] { \"false\", \"true\" };\n+        var query = context.QueryString ?? string.Empty;\n+\n+        var options = values\n+            .Where(v => v.StartsWith(query, StringComparison.OrdinalIgnoreCase))\n+            .Select(v => new AutoCompleteOption(v))\n+            .ToList();\n \n         return Task.FromResult(options);\n     }\ndiff --git a/BitPantry.CommandLine/AutoComplete/Handlers/HandlerActivator.cs b/BitPantry.CommandLine/AutoComplete/Handlers/HandlerActivator.cs\ndeleted file mode 100644\nindex 6768d05..0000000\n--- a/BitPantry.CommandLine/AutoComplete/Handlers/HandlerActivator.cs\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-using System;\n-using Microsoft.Extensions.DependencyInjection;\n-\n-namespace BitPantry.CommandLine.AutoComplete.Handlers\n-{\n-    /// <summary>\n-    /// Activates autocomplete handlers from the DI container.\n-    /// Mirrors the CommandActivator pattern.\n-    /// </summary>\n-    public class HandlerActivator\n-    {\n-        private readonly IServiceProvider _serviceProvider;\n-\n-        /// <summary>\n-        /// Creates a new handler activator.\n-        /// </summary>\n-        /// <param name=\"serviceProvider\">The service provider for resolving handlers</param>\n-        public HandlerActivator(IServiceProvider serviceProvider)\n-        {\n-            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));\n-        }\n-\n-        /// <summary>\n-        /// Resolves a handler instance from DI.\n-        /// </summary>\n-        /// <param name=\"handlerType\">The handler type to activate</param>\n-        /// <returns>The activated handler instance</returns>\n-        public IAutoCompleteHandler Activate(Type handlerType)\n-        {\n-            return (IAutoCompleteHandler)_serviceProvider.GetRequiredService(handlerType);\n-        }\n-\n-        /// <summary>\n-        /// Resolves a handler instance from DI.\n-        /// </summary>\n-        /// <typeparam name=\"THandler\">The handler type to activate</typeparam>\n-        /// <returns>The activated handler instance</returns>\n-        public THandler Activate<THandler>() where THandler : IAutoCompleteHandler\n-        {\n-            return _serviceProvider.GetRequiredService<THandler>();\n-        }\n-    }\n-}\ndiff --git a/BitPantry.CommandLine/AutoComplete/Handlers/IAutoCompleteHandlerRegistry.cs b/BitPantry.CommandLine/AutoComplete/Handlers/IAutoCompleteHandlerRegistry.cs\nindex ce57ca6..cca0266 100644\n--- a/BitPantry.CommandLine/AutoComplete/Handlers/IAutoCompleteHandlerRegistry.cs\n+++ b/BitPantry.CommandLine/AutoComplete/Handlers/IAutoCompleteHandlerRegistry.cs\n@@ -7,7 +7,7 @@ namespace BitPantry.CommandLine.AutoComplete.Handlers\n {\n     /// <summary>\n     /// Immutable registry for autocomplete handler lookup at runtime.\n-    /// Does NOT activate handlers - use HandlerActivator for that.\n+    /// Does NOT activate handlers - use AutoCompleteHandlerActivator for that.\n     /// </summary>\n     public interface IAutoCompleteHandlerRegistry\n     {\n@@ -19,7 +19,7 @@ namespace BitPantry.CommandLine.AutoComplete.Handlers\n         /// <param name=\"argumentInfo\">The argument to find a handler for</param>\n         /// <param name=\"activator\">The activator to use for checking CanHandle on type handlers</param>\n         /// <returns>The handler type, or null if none matches</returns>\n-        Type? FindHandler(ArgumentInfo argumentInfo, HandlerActivator activator);\n+        Type? FindHandler(ArgumentInfo argumentInfo, AutoCompleteHandlerActivator activator);\n \n         /// <summary>\n         /// Gets the count of registered type handlers.\ndiff --git a/BitPantry.CommandLine/Client/IServerProxy.cs b/BitPantry.CommandLine/Client/IServerProxy.cs\nindex 47c36fc..1976382 100644\n--- a/BitPantry.CommandLine/Client/IServerProxy.cs\n+++ b/BitPantry.CommandLine/Client/IServerProxy.cs\n@@ -1,4 +1,5 @@\n ∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using HandlerContext = BitPantry.CommandLine.AutoComplete.Handlers.AutoCompleteContext;\n using System;\n using System.Collections.Generic;\n using System.Threading;\n@@ -27,7 +28,7 @@ namespace BitPantry.CommandLine.Client\n         /// </summary>\n         ServerCapabilities Server { get; }\n \n-        Task<List<AutoCompleteOption>> AutoComplete(string groupPath, string cmdName, string functionName, bool isFunctionAsync, AutoCompleteContext ctx, CancellationToken token);\n+        Task<List<AutoCompleteOption>> AutoComplete(string groupPath, string cmdName, HandlerContext ctx, CancellationToken token);\n         Task Connect(string uri, CancellationToken token = default);\n         Task Disconnect(CancellationToken token = default);\n         Task<RunResult> Run(string commandLineInput, object data, CancellationToken token);\ndiff --git a/BitPantry.CommandLine/Client/NoopServerProxy.cs b/BitPantry.CommandLine/Client/NoopServerProxy.cs\nindex 5398768..266433a 100644\n--- a/BitPantry.CommandLine/Client/NoopServerProxy.cs\n+++ b/BitPantry.CommandLine/Client/NoopServerProxy.cs\n@@ -1,4 +1,5 @@\n ∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using HandlerContext = BitPantry.CommandLine.AutoComplete.Handlers.AutoCompleteContext;\n using System;\n using System.Collections.Generic;\n using System.Threading;\n@@ -17,7 +18,7 @@ namespace BitPantry.CommandLine.Client\n \n         public ServerCapabilities Server => throw new InvalidOperationException(_err);\n \n-        public Task<List<AutoCompleteOption>> AutoComplete(string groupPath, string cmdName, string functionName, bool isFunctionAsync, AutoCompleteContext ctx, CancellationToken token)\n+        public Task<List<AutoCompleteOption>> AutoComplete(string groupPath, string cmdName, HandlerContext ctx, CancellationToken token)\n         {\n             throw new InvalidOperationException(_err);\n         }\ndiff --git a/BitPantry.CommandLine/CommandLineApplicationBuilder.cs b/BitPantry.CommandLine/CommandLineApplicationBuilder.cs\nindex 6d2776d..cc28ca2 100644\n--- a/BitPantry.CommandLine/CommandLineApplicationBuilder.cs\n+++ b/BitPantry.CommandLine/CommandLineApplicationBuilder.cs\n@@ -1,4 +1,6 @@\n ∩╗┐using BitPantry.CommandLine.AutoComplete;\n+using BitPantry.CommandLine.AutoComplete.Handlers;\n+using BitPantry.CommandLine.Commands;\n using BitPantry.CommandLine.Processing.Activation;\n using BitPantry.CommandLine.Processing.Execution;\n using BitPantry.CommandLine.Input;\n@@ -6,7 +8,6 @@ using Microsoft.Extensions.DependencyInjection;\n using Spectre.Console;\n using Microsoft.Extensions.Logging;\n using Microsoft.Extensions.Logging.Abstractions;\n-using BitPantry.CommandLine.Commands;\n using BitPantry.CommandLine.Client;\n using BitPantry.CommandLine.Help;\n using System.Text;\n@@ -31,14 +32,13 @@ namespace BitPantry.CommandLine\n \n             Services = new ServiceCollection();\n \n+            // Register built-in commands\n+            CommandRegistryBuilder.RegisterCommand<ListCommandsCommand>();\n+\n             // the server proxy is disabled by default\n \n             Services.AddFileSystem();\n             Services.AddSingleton<IServerProxy, NoopServerProxy>();\n-\n-            // core commands\n-\n-            CommandRegistryBuilder.RegisterCommand<ListCommandsCommand>();\n         }\n \n         /// <summary>\n@@ -180,8 +180,12 @@ namespace BitPantry.CommandLine\n                 serverProxy,\n                 helpFormatter);\n \n+            // Build autocomplete handler registry\n+            var handlerRegistryBuilder = new AutoCompleteHandlerRegistryBuilder();\n+            var handlerRegistry = handlerRegistryBuilder.Build(Services);\n+\n             var acCtrl = new AutoCompleteController(\n-                new AutoCompleteOptionSetBuilder(commandRegistry, serverProxy, svcProvider));\n+                new AutoCompleteOptionSetBuilder(commandRegistry, serverProxy, svcProvider, handlerRegistry));\n \n             // Get the prompt from DI\n             var prompt = svcProvider.GetRequiredService<IPrompt>();\ndiff --git a/BitPantry.CommandLine/Component/ArgumentInfo.cs b/BitPantry.CommandLine/Component/ArgumentInfo.cs\nindex c251ed4..e66569e 100644\n--- a/BitPantry.CommandLine/Component/ArgumentInfo.cs\n+++ b/BitPantry.CommandLine/Component/ArgumentInfo.cs\n@@ -31,18 +31,6 @@ namespace BitPantry.CommandLine.Component\n         [JsonInclude]\n         public SerializablePropertyInfo PropertyInfo { get; internal set; }\n \n-        /// <summary>\n-        /// The name of the function in the same class as the argument that can provide auto complete values - the function should accept an AutoCompleteContext and return a List<string>\n-        /// </summary>\n-        [JsonInclude]\n-        public string AutoCompleteFunctionName { get; internal set; }\n-\n-        /// <summary>\n-        /// Whether or not the auto complete function defined (if any) is asynchronous\n-        /// </summary>\n-        [JsonInclude]\n-        public bool IsAutoCompleteFunctionAsync { get; internal set; }\n-\n         /// <summary>\n         /// Whether or not the argument is required\n         /// </summary>\ndiff --git a/BitPantry.CommandLine/Processing/Description/CommandReflection.cs b/BitPantry.CommandLine/Processing/Description/CommandReflection.cs\nindex fb442e9..e96a767 100644\n--- a/BitPantry.CommandLine/Processing/Description/CommandReflection.cs\n+++ b/BitPantry.CommandLine/Processing/Description/CommandReflection.cs\n@@ -132,54 +132,11 @@ namespace BitPantry.CommandLine.Processing.Description\n                     var aliasAttr = GetAttributes<AliasAttribute>(property).SingleOrDefault();\n                     var descAttr = GetAttributes<DescriptionAttribute>(property).SingleOrDefault();\n \n-                    // auto complete function\n-\n-                    var isAutoCompleteFunctionAsync = false;\n-\n-                    if (!string.IsNullOrEmpty(paramAttr.AutoCompleteFunctionName))\n-                    {\n-                        var badAutoCompleteFunctionException = new CommandDescriptionException(commandType, $\"An auto complete function for argument, {property.Name}, could not be found with a signature of \\\"public List<AutoCompleteOption> {paramAttr.AutoCompleteFunctionName}(AutoCompleteContext)\\\" or \\\"public async Task<List<AutoCompleteOption>> {paramAttr.AutoCompleteFunctionName}(AutoCompleteContext)\\\"\");\n-\n-                        var method = commandType.GetMethod(paramAttr.AutoCompleteFunctionName);\n-\n-                        if (method == null)\n-                            throw badAutoCompleteFunctionException;\n-\n-                        isAutoCompleteFunctionAsync = method.IsAsync();\n-\n-                        // make sure it only has the one AutoCompleteContext argument\n-\n-                        var parameters = method.GetParameters();\n-                        if (parameters.Count() == 1)\n-                        {\n-                            if (!typeof(AutoCompleteContext).IsAssignableFrom(parameters[0].ParameterType))\n-                                throw badAutoCompleteFunctionException;\n-                        }\n-                        else\n-                        {\n-                            throw badAutoCompleteFunctionException;\n-                        }\n-\n-                        // make sure it returns a List<AutoCompleteOption>\n-\n-                        if (method.ReturnType == typeof(void))\n-                            throw badAutoCompleteFunctionException;\n-\n-                        var returnType = method.ReturnType.IsGenericType && method.ReturnType.GetGenericTypeDefinition() == typeof(Task<>)\n-                            ? method.ReturnType.GetGenericArguments().First()\n-                            : method.ReturnType;\n-\n-                        if (returnType != typeof(List<AutoCompleteOption>))\n-                            throw badAutoCompleteFunctionException;\n-                    }\n-\n                     // add info\n \n                     arguments.Add(new ArgumentInfo\n                     {\n                         Name = paramAttr.Name ?? property.Name,\n-                        AutoCompleteFunctionName = paramAttr.AutoCompleteFunctionName,\n-                        IsAutoCompleteFunctionAsync = isAutoCompleteFunctionAsync,\n                         Alias = aliasAttr == null ? default(char) : aliasAttr.Alias,\n                         Description = descAttr?.Description,\n                         PropertyInfo = new SerializablePropertyInfo(property),\ndiff --git a/specs/008-autocomplete-extensions/batch-state.json b/specs/008-autocomplete-extensions/batch-state.json\nindex ff75dc8..1f7a26c 100644\n--- a/specs/008-autocomplete-extensions/batch-state.json\n+++ b/specs/008-autocomplete-extensions/batch-state.json\n@@ -1,6 +1,6 @@\n {\n   \"activeBatch\": \"batch-003\",\n-  \"currentTask\": null,\n+  \"currentTask\": \"T036\",\n   \"taskStates\": {\n     \"T002\": {\n       \"phase\": \"verified\",\n@@ -22,7 +22,9 @@\n       \"phase\": \"pending\"\n     },\n     \"T029\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-20T15:06:09.8058301-06:00\"\n     },\n     \"T086\": {\n       \"phase\": \"pending\"\n@@ -73,7 +75,9 @@\n       \"phase\": \"pending\"\n     },\n     \"T031\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-21T16:28:50.7174472-06:00\"\n     },\n     \"T068\": {\n       \"phase\": \"pending\"\n@@ -91,7 +95,9 @@\n       \"phase\": \"pending\"\n     },\n     \"T035\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-21T16:57:53.2694721-06:00\"\n     },\n     \"T093\": {\n       \"phase\": \"pending\"\n@@ -100,7 +106,9 @@\n       \"phase\": \"pending\"\n     },\n     \"T034\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-21T16:55:42.650102-06:00\"\n     },\n     \"T012\": {\n       \"phase\": \"verified\",\n@@ -139,7 +147,9 @@\n       \"phase\": \"pending\"\n     },\n     \"T032\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-21T16:49:46.3949447-06:00\"\n     },\n     \"T017\": {\n       \"phase\": \"verified\",\n@@ -170,7 +180,8 @@\n       \"phase\": \"pending\"\n     },\n     \"T036\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"started\",\n+      \"status\": \"in-progress\"\n     },\n     \"T003\": {\n       \"phase\": \"verified\",\n@@ -178,7 +189,9 @@\n       \"verifiedAt\": \"2026-01-19T20:44:17.9932645-06:00\"\n     },\n     \"T033\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-21T16:52:53.5661174-06:00\"\n     },\n     \"T076\": {\n       \"phase\": \"pending\"\n@@ -208,7 +221,9 @@\n       \"verifiedAt\": \"2026-01-19T20:49:14.7133449-06:00\"\n     },\n     \"T026\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-20T14:56:53.0334106-06:00\"\n     },\n     \"T085\": {\n       \"phase\": \"pending\"\n@@ -220,7 +235,9 @@\n       \"phase\": \"pending\"\n     },\n     \"T028\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-20T15:03:32.8400063-06:00\"\n     },\n     \"T071\": {\n       \"phase\": \"pending\"\n@@ -298,7 +315,9 @@\n       \"verifiedAt\": \"2026-01-19T20:48:08.7061686-06:00\"\n     },\n     \"T025\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-20T14:40:07.1718955-06:00\"\n     },\n     \"T036b\": {\n       \"phase\": \"pending\"\n@@ -354,7 +373,9 @@\n       \"verifiedAt\": \"2026-01-19T20:50:16.7189366-06:00\"\n     },\n     \"T030\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-20T15:09:04.1869323-06:00\"\n     },\n     \"T066\": {\n       \"phase\": \"pending\"\n@@ -363,7 +384,7 @@\n       \"phase\": \"pending\"\n     }\n   },\n-  \"batchStatus\": \"pending\",\n+  \"batchStatus\": \"in-progress\",\n   \"completedBatches\": [\n     \"batch-001\",\n     \"batch-002\"\ndiff --git a/specs/008-autocomplete-extensions/batches/batch-003.md b/specs/008-autocomplete-extensions/batches/batch-003.md\nindex 5705f85..e4c6bda 100644\n--- a/specs/008-autocomplete-extensions/batches/batch-003.md\n+++ b/specs/008-autocomplete-extensions/batches/batch-003.md\n@@ -1,20 +1,20 @@\n # Batch 3: autocomplete-extensions\n \n **Created**: 2026-01-19\n-**Status**: pending\n-**Tasks**: 0 of 11 complete\n+**Status**: in-progress\n+**Tasks**: 10 of 14 complete\n \n ## Tasks\n-- [ ] T025 [depends:T024] @test-case:008:TC-2.11 `GetOptionsAsync` filters by prefix\n-- [ ] T026 [depends:T021,T025] Register `EnumAutoCompleteHandler` and `BooleanAutoCompleteHandler` by default in registry constructor\n-- [ ] T028 [depends:T009] @test-case:008:TC-3.2 `HandlerType` property returns correct type via `IAutoCompleteAttribute`\n-- [ ] T029 [depends:T028] @test-case:008:TC-3.3 Attribute works with `ITypeAutoCompleteHandler` types (compile-time test)\n-- [ ] T030 [depends:T029] @test-case:008:TC-3.4 Custom attributes inheriting `AutoCompleteAttribute<T>` are discoverable via marker interface\n-- [ ] T031 [depends:T026,T030] @test-case:008:TC-4.1 End-to-end enum autocomplete works with default application\n-- [ ] T032 [depends:T031] @test-case:008:TC-4.2 Custom Type Handler overrides built-in when registered after\n-- [ ] T033 [depends:T032] @test-case:008:TC-4.3 Attribute Handler used even when matching Type Handler exists\n-- [ ] T034 [depends:T033] @test-case:008:TC-4.4 Handler receives `ProvidedValues` in context with already-entered values\n-- [ ] T035 [depends:T034] @test-case:008:TC-4.5 Boolean autocomplete works end-to-end\n+- [X] T025 [depends:T024] @test-case:008:TC-2.11 `GetOptionsAsync` filters by prefix\n+- [X] T026 [depends:T021,T025] Register `EnumAutoCompleteHandler` and `BooleanAutoCompleteHandler` by default in registry constructor\n+- [X] T028 [depends:T009] @test-case:008:TC-3.2 `HandlerType` property returns correct type via `IAutoCompleteAttribute`\n+- [X] T029 [depends:T028] @test-case:008:TC-3.3 Attribute works with `ITypeAutoCompleteHandler` types (compile-time test)\n+- [X] T030 [depends:T029] @test-case:008:TC-3.4 Custom attributes inheriting `AutoCompleteAttribute<T>` are discoverable via marker interface\n+- [X] T031 [depends:T026,T030] @test-case:008:TC-4.1 End-to-end enum autocomplete works with default application\n+- [X] T032 [depends:T031] @test-case:008:TC-4.2 Custom Type Handler overrides built-in when registered after\n+- [X] T033 [depends:T032] @test-case:008:TC-4.3 Attribute Handler used even when matching Type Handler exists\n+- [X] T034 [depends:T033] @test-case:008:TC-4.4 Handler receives `ProvidedValues` in context with already-entered values\n+- [X] T035 [depends:T034] @test-case:008:TC-4.5 Boolean autocomplete works end-to-end\n - [ ] T036 [depends:T035] @test-case:008:TC-4.6 Nullable enum autocomplete works end-to-end\n \n ## Completion Criteria\n@@ -22,3 +22,13 @@\n - [ ] All tasks verified (evidence validated)\n - [ ] Full test suite passes (5 consecutive clean runs)\n - [ ] No open ambiguities\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\ndiff --git a/specs/008-autocomplete-extensions/handler-registry-freeze-impl-backlog.md b/specs/008-autocomplete-extensions/handler-registry-freeze-impl-backlog.md\nindex efd1c38..a1b685d 100644\n--- a/specs/008-autocomplete-extensions/handler-registry-freeze-impl-backlog.md\n+++ b/specs/008-autocomplete-extensions/handler-registry-freeze-impl-backlog.md\n@@ -12,7 +12,7 @@ Apply the same builder/freeze pattern used in `CommandRegistry` to `AutoComplete\n \n 1. Γ£à Split the mutable registration and immutable runtime concerns into separate interfaces/classes\n 2. Γ£à Move DI registration into `Build(IServiceCollection)`\n-3. Γ£à Introduce `HandlerActivator` to separate activation from the registry (mirrors `CommandActivator`)\n+3. Γ£à Introduce `AutoCompleteHandlerActivator` to separate activation from the registry (mirrors `CommandActivator`)\n 4. Γ£à Make the runtime registry truly immutable with no `IServiceProvider` dependency\n \n ---\n@@ -28,7 +28,7 @@ The handler system now mirrors the command system exactly:\n | **Build method** | `Build(IServiceCollection)` | `Build(IServiceCollection)` |\n | **Metadata storage** | Stores `CommandInfo` objects | Stores handler `Type` list |\n | **Lookup** | `Find()`, `FindCommand()` returns `CommandInfo` | `FindHandler()` returns `Type?` |\n-| **Activator** | `CommandActivator.Activate(CommandInfo)` | `HandlerActivator.Activate(Type)` |\n+| **Activator** | `CommandActivator.Activate(CommandInfo)` returns `ActivationResult` | `AutoCompleteHandlerActivator.Activate(Type)` returns `AutoCompleteHandlerActivationResult` |\n \n ---\n \n@@ -38,10 +38,11 @@ The handler system now mirrors the command system exactly:\n \n | File | Purpose |\n |------|---------|\n-| `IAutoCompleteHandlerRegistry.cs` | Runtime lookup interface with `FindHandler(ArgumentInfo, HandlerActivator)` |\n+| `IAutoCompleteHandlerRegistry.cs` | Runtime lookup interface with `FindHandler(ArgumentInfo, AutoCompleteHandlerActivator)` |\n | `IAutoCompleteHandlerRegistryBuilder.cs` | Builder interface with `Register<T>()` and `Build(IServiceCollection)` |\n | `AutoCompleteHandlerRegistryBuilder.cs` | Mutable builder that registers handler types with DI during Build() |\n-| `HandlerActivator.cs` | Activator class mirroring `CommandActivator` with `Activate(Type)` |\n+| `AutoCompleteHandlerActivator.cs` | Activator class mirroring `CommandActivator` with `Activate(Type)` returning `AutoCompleteHandlerActivationResult` |\n+| `AutoCompleteHandlerActivationResult.cs` | IDisposable result containing handler and scope, mirroring `ActivationResult` |\n \n ### Files Modified\n \n@@ -58,7 +59,7 @@ For the `CanHandle()` check (which requires activation), **Option B** was chosen\n \n ```csharp\n // Option B: Registry takes activator as parameter for the lookup\n-public Type? FindHandler(ArgumentInfo argumentInfo, HandlerActivator activator)\n+public Type? FindHandler(ArgumentInfo argumentInfo, AutoCompleteHandlerActivator activator)\n ```\n \n This allows the registry to perform the full lookup logic internally while still keeping activation separate via the activator parameter.\n@@ -71,7 +72,7 @@ This allows the registry to perform the full lookup logic internally while still\n - [x] Create `IAutoCompleteHandlerRegistryBuilder` interface\n - [x] Implement `AutoCompleteHandlerRegistryBuilder`\n - [x] Refactor `AutoCompleteHandlerRegistry` to immutable (returns `Type`)\n-- [x] Create `HandlerActivator` class\n+- [x] Create `AutoCompleteHandlerActivator` class\n - [ ] Update `CommandLineApplicationBuilder` to use builder (deferred - integration pending)\n - [x] Update tests to use builder + activator pattern\n - [ ] Update spec.md FR-003 (optional docs update)"
  }
}
