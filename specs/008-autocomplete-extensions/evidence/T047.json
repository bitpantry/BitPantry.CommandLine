{
  "taskId": "T047",
  "testCase": "",
  "green": {
    "timestamp": "2026-01-22T15:53:35.7026292-06:00",
    "testCommand": "",
    "exitCode": -1,
    "output": ""
  },
  "diff": {
    "timestamp": "2026-01-22T15:53:35.7026292-06:00",
    "files": [
      "BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs",
      "BitPantry.CommandLine/AutoComplete/AutoCompleteController.cs",
      "BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSet.cs",
      "BitPantry.CommandLine/Input/InputBuilder.cs",
      "specs/008-autocomplete-extensions/batch-state.json",
      "specs/008-autocomplete-extensions/batches/batch-005.md"
    ],
    "patch": "diff --git a/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs b/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs\nindex caea594..35379cf 100644\n--- a/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs\n+++ b/BitPantry.CommandLine.Tests/AutoCompleteControllerTests.cs\n@@ -669,6 +669,77 @@ namespace BitPantry.CommandLine.Tests\n             input.BufferPosition.Should().Be(\"AlphaCommand\".Length);\n         }\n \n+        /// <summary>\n+        /// Implements: 008:UX-002\n+        /// When ghost text is visible with only one matching option and user presses Tab,\n+        /// the ghost text is accepted and cursor moves to end of inserted text.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task TabAcceptsSingleOption_GhostTextAccepted_CursorAtEnd()\n+        {\n+            // Arrange - use myCommand which is the only command starting with \"myc\"\n+            // This ensures there's exactly one matching option\n+            _input.Write(\"myc\");\n+\n+            // Act - trigger autocomplete (shows ghost text preview)\n+            await _acCtrl.Begin(_input);\n+            \n+            // Verify ghost text is showing (preview state)\n+            _input.Buffer.Should().Be(\"myCommand\");\n+            _acCtrl.State.Should().Be(AutoCompleteState.GhostText, \"autocomplete should be in ghost text state\");\n+\n+            // Simulate Tab press by calling Accept()\n+            _acCtrl.Accept(_input);\n+\n+            // Assert\n+            // 1. Ghost text is now accepted (permanent in buffer)\n+            _input.Buffer.Should().Be(\"myCommand\", \n+                \"Tab should accept the single matching option\");\n+\n+            // 2. Cursor should be at end of inserted text\n+            _input.BufferPosition.Should().Be(\"myCommand\".Length,\n+                \"cursor should move to end of inserted text after Tab\");\n+\n+            // 3. Autocomplete should be idle (no more ghost text mode)\n+            _acCtrl.State.Should().Be(AutoCompleteState.Idle, \"autocomplete should be idle after Tab accept\");\n+        }\n+\n+        /// <summary>\n+        /// Implements: 008:UX-003\n+        /// When ghost text is visible with multiple matching options and user presses Tab,\n+        /// the ghost text clears and the menu opens with the first item selected.\n+        /// </summary>\n+        [TestMethod]\n+        public async Task TabOpensMenuForMultipleOptions_MenuOpensWithFirstItemSelected()\n+        {\n+            // Arrange - use \"com\" which matches both \"Command\" and \"CommandWithTwoArgs\"\n+            // This ensures there are multiple matching options\n+            _input.Write(\"com\");\n+\n+            // Act - trigger autocomplete (shows ghost text preview)\n+            await _acCtrl.Begin(_input);\n+\n+            // Verify we're in ghost text mode with the first match\n+            _acCtrl.State.Should().Be(AutoCompleteState.GhostText, \"should start in ghost text state\");\n+            _input.Buffer.Should().Be(\"Command\", \"ghost text should show first alphabetical match\");\n+\n+            // Simulate Tab press - with multiple options, this should open menu\n+            _acCtrl.Accept(_input);\n+\n+            // Assert\n+            // 1. State should transition to MenuOpen\n+            _acCtrl.State.Should().Be(AutoCompleteState.MenuOpen, \"Tab with multiple options should open menu\");\n+            _acCtrl.IsMenuOpen.Should().BeTrue(\"IsMenuOpen should be true\");\n+\n+            // 2. Ghost text should be cleared (no markup) - the buffer still has the current selection\n+            _input.Buffer.Should().Be(\"Command\", \"buffer should contain the current selection\");\n+\n+            // 3. Should be able to navigate through options\n+            _acCtrl.NextOption(_input);\n+            // After navigation in menu mode, the selection changes but we remain in menu\n+            _acCtrl.State.Should().Be(AutoCompleteState.MenuOpen, \"should remain in menu state after navigation\");\n+        }\n+\n         #endregion\n \n         #region Test Helpers\ndiff --git a/BitPantry.CommandLine/AutoComplete/AutoCompleteController.cs b/BitPantry.CommandLine/AutoComplete/AutoCompleteController.cs\nindex 7d94f7c..d93486d 100644\n--- a/BitPantry.CommandLine/AutoComplete/AutoCompleteController.cs\n+++ b/BitPantry.CommandLine/AutoComplete/AutoCompleteController.cs\n@@ -1,5 +1,6 @@\n ∩╗┐using BitPantry.CommandLine.Processing.Parsing;\n using BitPantry.CommandLine.Input;\n+using BitPantry.CommandLine.AutoComplete.Rendering;\n using Spectre.Console;\n using System;\n using System.Text;\n@@ -13,6 +14,7 @@ namespace BitPantry.CommandLine.AutoComplete\n         private AutoCompleteOptionSetBuilder _optionsBldr;\n         private CancellationTokenSource _pendingRequestCts;\n         private readonly object _ctsLock = new object();\n+        private readonly MenuRenderer _menuRenderer;\n \n         private readonly string defaultOptionMarkup = \"black on silver\";\n \n@@ -22,11 +24,30 @@ namespace BitPantry.CommandLine.AutoComplete\n         private AutoCompleteOptionSet _activeOptionsSet;\n         private int _activeAutoCompleteStartPosition;\n \n-        public bool IsEngaged => _activeOptionsSet != null;\n+        /// <summary>\n+        /// Gets the current state of the autocomplete controller.\n+        /// </summary>\n+        public AutoCompleteState State { get; private set; } = AutoCompleteState.Idle;\n+\n+        /// <summary>\n+        /// Gets whether ghost text is currently visible.\n+        /// </summary>\n+        public bool IsGhostTextVisible => State == AutoCompleteState.GhostText;\n+\n+        /// <summary>\n+        /// Gets whether the menu is currently open.\n+        /// </summary>\n+        public bool IsMenuOpen => State == AutoCompleteState.MenuOpen;\n \n         public AutoCompleteController(AutoCompleteOptionSetBuilder optionsBldr)\n+            : this(optionsBldr, null)\n+        {\n+        }\n+\n+        public AutoCompleteController(AutoCompleteOptionSetBuilder optionsBldr, IAnsiConsole console)\n         {\n             _optionsBldr = optionsBldr;\n+            _menuRenderer = console != null ? new MenuRenderer(console) : null;\n         }\n \n         public async Task Begin(ConsoleLineMirror inputLine)\n@@ -52,9 +73,15 @@ namespace BitPantry.CommandLine.AutoComplete\n                 _activeOptionsSet = await _optionsBldr.BuildOptions(_activeParsedElement, token);\n \n                 if (_activeOptionsSet == null) // no options, end auto complete\n+                {\n                     _activeOptionsSet = null;\n+                    State = AutoCompleteState.Idle;\n+                }\n                 else // preview the current option to the console\n+                {\n+                    State = AutoCompleteState.GhostText;\n                     PreviewCurrentOption(inputLine, defaultOptionMarkup);\n+                }\n             }\n             catch (OperationCanceledException)\n             {\n@@ -131,17 +158,51 @@ namespace BitPantry.CommandLine.AutoComplete\n         public void PreviousOption(ConsoleLineMirror input)\n         {\n             if (_activeOptionsSet.PreviousOption())\n-                PreviewCurrentOption(input, defaultOptionMarkup);\n+            {\n+                if (State == AutoCompleteState.GhostText)\n+                {\n+                    PreviewCurrentOption(input, defaultOptionMarkup);\n+                }\n+                else if (State == AutoCompleteState.MenuOpen)\n+                {\n+                    // Update menu selection\n+                    _menuRenderer?.Update(\n+                        _activeOptionsSet.Options,\n+                        _activeOptionsSet.CurrentIndex,\n+                        0,\n+                        AutoCompleteConstants.DefaultVisibleMenuItems);\n+                }\n+            }\n         }\n \n         public void NextOption(ConsoleLineMirror input)\n         {\n             if (_activeOptionsSet.NextOption())\n-                PreviewCurrentOption(input, defaultOptionMarkup);\n+            {\n+                if (State == AutoCompleteState.GhostText)\n+                {\n+                    PreviewCurrentOption(input, defaultOptionMarkup);\n+                }\n+                else if (State == AutoCompleteState.MenuOpen)\n+                {\n+                    // Update menu selection\n+                    _menuRenderer?.Update(\n+                        _activeOptionsSet.Options,\n+                        _activeOptionsSet.CurrentIndex,\n+                        0,\n+                        AutoCompleteConstants.DefaultVisibleMenuItems);\n+                }\n+            }\n         }\n \n         public void Cancel(ConsoleLineMirror inputLine)\n         {\n+            // If menu is open, hide it first\n+            if (State == AutoCompleteState.MenuOpen)\n+            {\n+                _menuRenderer?.Hide();\n+            }\n+\n             SetOverwrite(inputLine, (line) =>\n             {\n                 line.HideCursor();\n@@ -152,18 +213,78 @@ namespace BitPantry.CommandLine.AutoComplete\n                 line.ShowCursor();\n             });\n             _activeOptionsSet = null;\n+            State = AutoCompleteState.Idle;\n         }\n \n         public void Accept(ConsoleLineMirror input)\n         {\n+            if (State == AutoCompleteState.GhostText)\n+            {\n+                // In ghost text mode: check if single or multiple options\n+                if (_activeOptionsSet.Options.Count > 1)\n+                {\n+                    // Multiple options - open menu\n+                    OpenMenu(input);\n+                }\n+                else\n+                {\n+                    // Single option - accept immediately\n+                    PreviewCurrentOption(input, null);\n+                    _activeOptionsSet = null;\n+                    State = AutoCompleteState.Idle;\n+                }\n+            }\n+            else if (State == AutoCompleteState.MenuOpen)\n+            {\n+                // In menu mode: accept current selection\n+                AcceptSelection(input);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Opens the menu displaying all available options.\n+        /// Called when Tab is pressed with multiple options.\n+        /// </summary>\n+        private void OpenMenu(ConsoleLineMirror input)\n+        {\n+            // Clear ghost text first (write without markup)\n             PreviewCurrentOption(input, null);\n+            \n+            State = AutoCompleteState.MenuOpen;\n+            \n+            // Render the menu\n+            _menuRenderer?.Show(\n+                _activeOptionsSet.Options, \n+                _activeOptionsSet.CurrentIndex, \n+                0, \n+                AutoCompleteConstants.DefaultVisibleMenuItems);\n+        }\n+\n+        /// <summary>\n+        /// Accepts the currently selected menu option.\n+        /// </summary>\n+        public void AcceptSelection(ConsoleLineMirror input)\n+        {\n+            // Hide the menu\n+            _menuRenderer?.Hide();\n+            \n+            // The current option is already in the buffer from PreviewCurrentOption\n+            // Just clear state\n             _activeOptionsSet = null;\n+            State = AutoCompleteState.Idle;\n         }\n \n         public void End(ConsoleLineMirror input)\n         {\n+            // If menu is open, hide it first\n+            if (State == AutoCompleteState.MenuOpen)\n+            {\n+                _menuRenderer?.Hide();\n+            }\n+\n             PreviewCurrentOption(input, null);\n             _activeOptionsSet = null;\n+            State = AutoCompleteState.Idle;\n         }\n \n         private void SetOverwrite(ConsoleLineMirror line, Action<ConsoleLineMirror> action)\ndiff --git a/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSet.cs b/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSet.cs\nindex 23f8c30..787e1e2 100644\n--- a/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSet.cs\n+++ b/BitPantry.CommandLine/AutoComplete/AutoCompleteOptionSet.cs\n@@ -15,6 +15,11 @@ namespace BitPantry.CommandLine.AutoComplete\n         /// </summary>\n         public IReadOnlyList<AutoCompleteOption> Options => _options.AsReadOnly();\n \n+        /// <summary>\n+        /// Gets the index of the currently selected option.\n+        /// </summary>\n+        public int CurrentIndex => _currentIndex;\n+\n         /// <summary>\n         /// Gets the currently selected option.\n         /// </summary>\ndiff --git a/BitPantry.CommandLine/Input/InputBuilder.cs b/BitPantry.CommandLine/Input/InputBuilder.cs\nindex 71f67db..2446e6c 100644\n--- a/BitPantry.CommandLine/Input/InputBuilder.cs\n+++ b/BitPantry.CommandLine/Input/InputBuilder.cs\n@@ -30,12 +30,14 @@ namespace BitPantry.CommandLine.Input\n                 var input = await new ConsoleInputInterceptor(_console)\n                     .AddHandler(ConsoleKey.Tab, async ctx =>\n                     {\n-                        if (_acCtrl.IsEngaged)\n+                        if (_acCtrl.State != AutoCompleteState.Idle)\n                         {\n                             if (ctx.KeyInfo.Modifiers == ConsoleModifiers.Shift)\n                                 _acCtrl.PreviousOption(ctx.InputLine);\n-                            else\n+                            else if (_acCtrl.IsMenuOpen)\n                                 _acCtrl.NextOption(ctx.InputLine);\n+                            else\n+                                _acCtrl.Accept(ctx.InputLine); // Tab in ghost text mode\n                         }\n                         else\n                         {\n@@ -46,7 +48,7 @@ namespace BitPantry.CommandLine.Input\n                     })\n                     .AddHandler(ConsoleKey.Escape, async ctx =>\n                     {\n-                        if (!_acCtrl.IsEngaged)\n+                        if (_acCtrl.State == AutoCompleteState.Idle)\n                             return await Task.FromResult(false);\n \n                         _acCtrl.Cancel(ctx.InputLine);\n@@ -54,7 +56,7 @@ namespace BitPantry.CommandLine.Input\n                     })\n                     .AddHandler(ConsoleKey.Enter, async ctx =>\n                     {\n-                        if (!_acCtrl.IsEngaged)\n+                        if (_acCtrl.State == AutoCompleteState.Idle)\n                             return await Task.FromResult(false);\n \n                         _acCtrl.Accept(ctx.InputLine);\n@@ -62,11 +64,17 @@ namespace BitPantry.CommandLine.Input\n                     })\n                     .AddHandler(ConsoleKey.UpArrow, async ctx =>\n                     {\n+                        if (_acCtrl.IsMenuOpen)\n+                        {\n+                            _acCtrl.PreviousOption(ctx.InputLine);\n+                            return await Task.FromResult(true);\n+                        }\n+\n                         if (_inputLog.Previous())\n                         {\n                             ctx.InputLine.HideCursor();\n \n-                            if (_acCtrl.IsEngaged)\n+                            if (_acCtrl.State != AutoCompleteState.Idle)\n                                 _acCtrl.End(ctx.InputLine);\n \n                             _inputLog.WriteLineAtCurrentIndex(ctx.InputLine);\n@@ -80,11 +88,17 @@ namespace BitPantry.CommandLine.Input\n                     })\n                     .AddHandler(ConsoleKey.DownArrow, async ctx =>\n                     {\n+                        if (_acCtrl.IsMenuOpen)\n+                        {\n+                            _acCtrl.NextOption(ctx.InputLine);\n+                            return await Task.FromResult(true);\n+                        }\n+\n                         if (_inputLog.Next())\n                         {\n                             ctx.InputLine.HideCursor();\n \n-                            if (_acCtrl.IsEngaged)\n+                            if (_acCtrl.State != AutoCompleteState.Idle)\n                                 _acCtrl.End(ctx.InputLine);\n \n                             ctx.InputLine.ShowCursor();\n@@ -98,7 +112,7 @@ namespace BitPantry.CommandLine.Input\n                     })\n                     .AddDefaultHandler(async ctx =>\n                     {\n-                        if (_acCtrl.IsEngaged)\n+                        if (_acCtrl.State != AutoCompleteState.Idle)\n                             _acCtrl.End(ctx.InputLine);\n                         return await Task.FromResult(false);\n                     })\ndiff --git a/specs/008-autocomplete-extensions/batch-state.json b/specs/008-autocomplete-extensions/batch-state.json\nindex b66ce94..fac9805 100644\n--- a/specs/008-autocomplete-extensions/batch-state.json\n+++ b/specs/008-autocomplete-extensions/batch-state.json\n@@ -1,6 +1,6 @@\n {\n   \"activeBatch\": \"batch-005\",\n-  \"currentTask\": null,\n+  \"currentTask\": \"T047\",\n   \"taskStates\": {\n     \"T002\": {\n       \"phase\": \"verified\",\n@@ -23,7 +23,8 @@\n       \"verifiedAt\": \"2026-01-19T21:33:51.1023429-06:00\"\n     },\n     \"T047\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"started\",\n+      \"status\": \"in-progress\"\n     },\n     \"T029\": {\n       \"phase\": \"verified\",\n@@ -356,7 +357,9 @@\n       \"phase\": \"pending\"\n     },\n     \"T046\": {\n-      \"phase\": \"pending\"\n+      \"phase\": \"verified\",\n+      \"status\": \"verified\",\n+      \"verifiedAt\": \"2026-01-21T19:20:03.488378-06:00\"\n     },\n     \"T097\": {\n       \"phase\": \"pending\"\n@@ -404,7 +407,7 @@\n       \"phase\": \"pending\"\n     }\n   },\n-  \"batchStatus\": \"pending\",\n+  \"batchStatus\": \"in-progress\",\n   \"completedBatches\": [\n     \"batch-001\",\n     \"batch-002\",\ndiff --git a/specs/008-autocomplete-extensions/batches/batch-005.md b/specs/008-autocomplete-extensions/batches/batch-005.md\nindex 0da15ef..1711e1f 100644\n--- a/specs/008-autocomplete-extensions/batches/batch-005.md\n+++ b/specs/008-autocomplete-extensions/batches/batch-005.md\n@@ -1,11 +1,11 @@\n # Batch 5: autocomplete-extensions\n \n **Created**: 2026-01-19\n-**Status**: pending\n-**Tasks**: 0 of 12 complete\n+**Status**: in-progress\n+**Tasks**: 1 of 15 complete\n \n ## Tasks\n-- [ ] T046 [depends:T045] @test-case:008:UX-002 Tab accepts single option (no menu)\n+- [X] T046 [depends:T045] @test-case:008:UX-002 Tab accepts single option (no menu)\n - [ ] T047 [depends:T046] @test-case:008:UX-003 Tab opens menu when multiple options exist\n - [ ] T048 [depends:T047] @test-case:008:UX-004 Right Arrow accepts ghost text\n - [ ] T049 [depends:T048] @test-case:008:UX-008 Escape dismisses ghost text\n@@ -23,3 +23,4 @@\n - [ ] All tasks verified (evidence validated)\n - [ ] Full test suite passes (5 consecutive clean runs)\n - [ ] No open ambiguities\n+"
  },
  "verifiedAt": "2026-01-22T15:53:43.0888272-06:00"
}
